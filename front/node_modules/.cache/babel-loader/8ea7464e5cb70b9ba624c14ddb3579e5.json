{"ast":null,"code":"'use strict';\n\nconst DEFAULT_RAW = {\n  colon: ': ',\n  indent: '    ',\n  beforeDecl: '\\n',\n  beforeRule: '\\n',\n  beforeOpen: ' ',\n  beforeClose: '\\n',\n  beforeComment: '\\n',\n  after: '\\n',\n  emptyBody: '',\n  commentLeft: ' ',\n  commentRight: ' ',\n  semicolon: false\n};\n\nfunction capitalize(str) {\n  return str[0].toUpperCase() + str.slice(1);\n}\n\nclass Stringifier {\n  constructor(builder) {\n    this.builder = builder;\n  }\n\n  stringify(node, semicolon) {\n    /* c8 ignore start */\n    if (!this[node.type]) {\n      throw new Error('Unknown AST node type ' + node.type + '. ' + 'Maybe you need to change PostCSS stringifier.');\n    }\n    /* c8 ignore stop */\n\n\n    this[node.type](node, semicolon);\n  }\n\n  document(node) {\n    this.body(node);\n  }\n\n  root(node) {\n    this.body(node);\n    if (node.raws.after) this.builder(node.raws.after);\n  }\n\n  comment(node) {\n    let left = this.raw(node, 'left', 'commentLeft');\n    let right = this.raw(node, 'right', 'commentRight');\n    this.builder('/*' + left + node.text + right + '*/', node);\n  }\n\n  decl(node, semicolon) {\n    let between = this.raw(node, 'between', 'colon');\n    let string = node.prop + between + this.rawValue(node, 'value');\n\n    if (node.important) {\n      string += node.raws.important || ' !important';\n    }\n\n    if (semicolon) string += ';';\n    this.builder(string, node);\n  }\n\n  rule(node) {\n    this.block(node, this.rawValue(node, 'selector'));\n\n    if (node.raws.ownSemicolon) {\n      this.builder(node.raws.ownSemicolon, node, 'end');\n    }\n  }\n\n  atrule(node, semicolon) {\n    let name = '@' + node.name;\n    let params = node.params ? this.rawValue(node, 'params') : '';\n\n    if (typeof node.raws.afterName !== 'undefined') {\n      name += node.raws.afterName;\n    } else if (params) {\n      name += ' ';\n    }\n\n    if (node.nodes) {\n      this.block(node, name + params);\n    } else {\n      let end = (node.raws.between || '') + (semicolon ? ';' : '');\n      this.builder(name + params + end, node);\n    }\n  }\n\n  body(node) {\n    let last = node.nodes.length - 1;\n\n    while (last > 0) {\n      if (node.nodes[last].type !== 'comment') break;\n      last -= 1;\n    }\n\n    let semicolon = this.raw(node, 'semicolon');\n\n    for (let i = 0; i < node.nodes.length; i++) {\n      let child = node.nodes[i];\n      let before = this.raw(child, 'before');\n      if (before) this.builder(before);\n      this.stringify(child, last !== i || semicolon);\n    }\n  }\n\n  block(node, start) {\n    let between = this.raw(node, 'between', 'beforeOpen');\n    this.builder(start + between + '{', node, 'start');\n    let after;\n\n    if (node.nodes && node.nodes.length) {\n      this.body(node);\n      after = this.raw(node, 'after');\n    } else {\n      after = this.raw(node, 'after', 'emptyBody');\n    }\n\n    if (after) this.builder(after);\n    this.builder('}', node, 'end');\n  }\n\n  raw(node, own, detect) {\n    let value;\n    if (!detect) detect = own; // Already had\n\n    if (own) {\n      value = node.raws[own];\n      if (typeof value !== 'undefined') return value;\n    }\n\n    let parent = node.parent;\n\n    if (detect === 'before') {\n      // Hack for first rule in CSS\n      if (!parent || parent.type === 'root' && parent.first === node) {\n        return '';\n      } // `root` nodes in `document` should use only their own raws\n\n\n      if (parent && parent.type === 'document') {\n        return '';\n      }\n    } // Floating child without parent\n\n\n    if (!parent) return DEFAULT_RAW[detect]; // Detect style by other nodes\n\n    let root = node.root();\n    if (!root.rawCache) root.rawCache = {};\n\n    if (typeof root.rawCache[detect] !== 'undefined') {\n      return root.rawCache[detect];\n    }\n\n    if (detect === 'before' || detect === 'after') {\n      return this.beforeAfter(node, detect);\n    } else {\n      let method = 'raw' + capitalize(detect);\n\n      if (this[method]) {\n        value = this[method](root, node);\n      } else {\n        root.walk(i => {\n          value = i.raws[own];\n          if (typeof value !== 'undefined') return false;\n        });\n      }\n    }\n\n    if (typeof value === 'undefined') value = DEFAULT_RAW[detect];\n    root.rawCache[detect] = value;\n    return value;\n  }\n\n  rawSemicolon(root) {\n    let value;\n    root.walk(i => {\n      if (i.nodes && i.nodes.length && i.last.type === 'decl') {\n        value = i.raws.semicolon;\n        if (typeof value !== 'undefined') return false;\n      }\n    });\n    return value;\n  }\n\n  rawEmptyBody(root) {\n    let value;\n    root.walk(i => {\n      if (i.nodes && i.nodes.length === 0) {\n        value = i.raws.after;\n        if (typeof value !== 'undefined') return false;\n      }\n    });\n    return value;\n  }\n\n  rawIndent(root) {\n    if (root.raws.indent) return root.raws.indent;\n    let value;\n    root.walk(i => {\n      let p = i.parent;\n\n      if (p && p !== root && p.parent && p.parent === root) {\n        if (typeof i.raws.before !== 'undefined') {\n          let parts = i.raws.before.split('\\n');\n          value = parts[parts.length - 1];\n          value = value.replace(/\\S/g, '');\n          return false;\n        }\n      }\n    });\n    return value;\n  }\n\n  rawBeforeComment(root, node) {\n    let value;\n    root.walkComments(i => {\n      if (typeof i.raws.before !== 'undefined') {\n        value = i.raws.before;\n\n        if (value.includes('\\n')) {\n          value = value.replace(/[^\\n]+$/, '');\n        }\n\n        return false;\n      }\n    });\n\n    if (typeof value === 'undefined') {\n      value = this.raw(node, null, 'beforeDecl');\n    } else if (value) {\n      value = value.replace(/\\S/g, '');\n    }\n\n    return value;\n  }\n\n  rawBeforeDecl(root, node) {\n    let value;\n    root.walkDecls(i => {\n      if (typeof i.raws.before !== 'undefined') {\n        value = i.raws.before;\n\n        if (value.includes('\\n')) {\n          value = value.replace(/[^\\n]+$/, '');\n        }\n\n        return false;\n      }\n    });\n\n    if (typeof value === 'undefined') {\n      value = this.raw(node, null, 'beforeRule');\n    } else if (value) {\n      value = value.replace(/\\S/g, '');\n    }\n\n    return value;\n  }\n\n  rawBeforeRule(root) {\n    let value;\n    root.walk(i => {\n      if (i.nodes && (i.parent !== root || root.first !== i)) {\n        if (typeof i.raws.before !== 'undefined') {\n          value = i.raws.before;\n\n          if (value.includes('\\n')) {\n            value = value.replace(/[^\\n]+$/, '');\n          }\n\n          return false;\n        }\n      }\n    });\n    if (value) value = value.replace(/\\S/g, '');\n    return value;\n  }\n\n  rawBeforeClose(root) {\n    let value;\n    root.walk(i => {\n      if (i.nodes && i.nodes.length > 0) {\n        if (typeof i.raws.after !== 'undefined') {\n          value = i.raws.after;\n\n          if (value.includes('\\n')) {\n            value = value.replace(/[^\\n]+$/, '');\n          }\n\n          return false;\n        }\n      }\n    });\n    if (value) value = value.replace(/\\S/g, '');\n    return value;\n  }\n\n  rawBeforeOpen(root) {\n    let value;\n    root.walk(i => {\n      if (i.type !== 'decl') {\n        value = i.raws.between;\n        if (typeof value !== 'undefined') return false;\n      }\n    });\n    return value;\n  }\n\n  rawColon(root) {\n    let value;\n    root.walkDecls(i => {\n      if (typeof i.raws.between !== 'undefined') {\n        value = i.raws.between.replace(/[^\\s:]/g, '');\n        return false;\n      }\n    });\n    return value;\n  }\n\n  beforeAfter(node, detect) {\n    let value;\n\n    if (node.type === 'decl') {\n      value = this.raw(node, null, 'beforeDecl');\n    } else if (node.type === 'comment') {\n      value = this.raw(node, null, 'beforeComment');\n    } else if (detect === 'before') {\n      value = this.raw(node, null, 'beforeRule');\n    } else {\n      value = this.raw(node, null, 'beforeClose');\n    }\n\n    let buf = node.parent;\n    let depth = 0;\n\n    while (buf && buf.type !== 'root') {\n      depth += 1;\n      buf = buf.parent;\n    }\n\n    if (value.includes('\\n')) {\n      let indent = this.raw(node, null, 'indent');\n\n      if (indent.length) {\n        for (let step = 0; step < depth; step++) value += indent;\n      }\n    }\n\n    return value;\n  }\n\n  rawValue(node, prop) {\n    let value = node[prop];\n    let raw = node.raws[prop];\n\n    if (raw && raw.value === value) {\n      return raw.raw;\n    }\n\n    return value;\n  }\n\n}\n\nmodule.exports = Stringifier;\nStringifier.default = Stringifier;","map":{"version":3,"sources":["/Users/dylanmurray/Sweng-2022/front/node_modules/postcss/lib/stringifier.js"],"names":["DEFAULT_RAW","colon","indent","beforeDecl","beforeRule","beforeOpen","beforeClose","beforeComment","after","emptyBody","commentLeft","commentRight","semicolon","capitalize","str","toUpperCase","slice","Stringifier","constructor","builder","stringify","node","type","Error","document","body","root","raws","comment","left","raw","right","text","decl","between","string","prop","rawValue","important","rule","block","ownSemicolon","atrule","name","params","afterName","nodes","end","last","length","i","child","before","start","own","detect","value","parent","first","rawCache","beforeAfter","method","walk","rawSemicolon","rawEmptyBody","rawIndent","p","parts","split","replace","rawBeforeComment","walkComments","includes","rawBeforeDecl","walkDecls","rawBeforeRule","rawBeforeClose","rawBeforeOpen","rawColon","buf","depth","step","module","exports","default"],"mappings":"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","sourcesContent":["'use strict'\n\nconst DEFAULT_RAW = {\n  colon: ': ',\n  indent: '    ',\n  beforeDecl: '\\n',\n  beforeRule: '\\n',\n  beforeOpen: ' ',\n  beforeClose: '\\n',\n  beforeComment: '\\n',\n  after: '\\n',\n  emptyBody: '',\n  commentLeft: ' ',\n  commentRight: ' ',\n  semicolon: false\n}\n\nfunction capitalize(str) {\n  return str[0].toUpperCase() + str.slice(1)\n}\n\nclass Stringifier {\n  constructor(builder) {\n    this.builder = builder\n  }\n\n  stringify(node, semicolon) {\n    /* c8 ignore start */\n    if (!this[node.type]) {\n      throw new Error(\n        'Unknown AST node type ' +\n          node.type +\n          '. ' +\n          'Maybe you need to change PostCSS stringifier.'\n      )\n    }\n    /* c8 ignore stop */\n    this[node.type](node, semicolon)\n  }\n\n  document(node) {\n    this.body(node)\n  }\n\n  root(node) {\n    this.body(node)\n    if (node.raws.after) this.builder(node.raws.after)\n  }\n\n  comment(node) {\n    let left = this.raw(node, 'left', 'commentLeft')\n    let right = this.raw(node, 'right', 'commentRight')\n    this.builder('/*' + left + node.text + right + '*/', node)\n  }\n\n  decl(node, semicolon) {\n    let between = this.raw(node, 'between', 'colon')\n    let string = node.prop + between + this.rawValue(node, 'value')\n\n    if (node.important) {\n      string += node.raws.important || ' !important'\n    }\n\n    if (semicolon) string += ';'\n    this.builder(string, node)\n  }\n\n  rule(node) {\n    this.block(node, this.rawValue(node, 'selector'))\n    if (node.raws.ownSemicolon) {\n      this.builder(node.raws.ownSemicolon, node, 'end')\n    }\n  }\n\n  atrule(node, semicolon) {\n    let name = '@' + node.name\n    let params = node.params ? this.rawValue(node, 'params') : ''\n\n    if (typeof node.raws.afterName !== 'undefined') {\n      name += node.raws.afterName\n    } else if (params) {\n      name += ' '\n    }\n\n    if (node.nodes) {\n      this.block(node, name + params)\n    } else {\n      let end = (node.raws.between || '') + (semicolon ? ';' : '')\n      this.builder(name + params + end, node)\n    }\n  }\n\n  body(node) {\n    let last = node.nodes.length - 1\n    while (last > 0) {\n      if (node.nodes[last].type !== 'comment') break\n      last -= 1\n    }\n\n    let semicolon = this.raw(node, 'semicolon')\n    for (let i = 0; i < node.nodes.length; i++) {\n      let child = node.nodes[i]\n      let before = this.raw(child, 'before')\n      if (before) this.builder(before)\n      this.stringify(child, last !== i || semicolon)\n    }\n  }\n\n  block(node, start) {\n    let between = this.raw(node, 'between', 'beforeOpen')\n    this.builder(start + between + '{', node, 'start')\n\n    let after\n    if (node.nodes && node.nodes.length) {\n      this.body(node)\n      after = this.raw(node, 'after')\n    } else {\n      after = this.raw(node, 'after', 'emptyBody')\n    }\n\n    if (after) this.builder(after)\n    this.builder('}', node, 'end')\n  }\n\n  raw(node, own, detect) {\n    let value\n    if (!detect) detect = own\n\n    // Already had\n    if (own) {\n      value = node.raws[own]\n      if (typeof value !== 'undefined') return value\n    }\n\n    let parent = node.parent\n\n    if (detect === 'before') {\n      // Hack for first rule in CSS\n      if (!parent || (parent.type === 'root' && parent.first === node)) {\n        return ''\n      }\n\n      // `root` nodes in `document` should use only their own raws\n      if (parent && parent.type === 'document') {\n        return ''\n      }\n    }\n\n    // Floating child without parent\n    if (!parent) return DEFAULT_RAW[detect]\n\n    // Detect style by other nodes\n    let root = node.root()\n    if (!root.rawCache) root.rawCache = {}\n    if (typeof root.rawCache[detect] !== 'undefined') {\n      return root.rawCache[detect]\n    }\n\n    if (detect === 'before' || detect === 'after') {\n      return this.beforeAfter(node, detect)\n    } else {\n      let method = 'raw' + capitalize(detect)\n      if (this[method]) {\n        value = this[method](root, node)\n      } else {\n        root.walk(i => {\n          value = i.raws[own]\n          if (typeof value !== 'undefined') return false\n        })\n      }\n    }\n\n    if (typeof value === 'undefined') value = DEFAULT_RAW[detect]\n\n    root.rawCache[detect] = value\n    return value\n  }\n\n  rawSemicolon(root) {\n    let value\n    root.walk(i => {\n      if (i.nodes && i.nodes.length && i.last.type === 'decl') {\n        value = i.raws.semicolon\n        if (typeof value !== 'undefined') return false\n      }\n    })\n    return value\n  }\n\n  rawEmptyBody(root) {\n    let value\n    root.walk(i => {\n      if (i.nodes && i.nodes.length === 0) {\n        value = i.raws.after\n        if (typeof value !== 'undefined') return false\n      }\n    })\n    return value\n  }\n\n  rawIndent(root) {\n    if (root.raws.indent) return root.raws.indent\n    let value\n    root.walk(i => {\n      let p = i.parent\n      if (p && p !== root && p.parent && p.parent === root) {\n        if (typeof i.raws.before !== 'undefined') {\n          let parts = i.raws.before.split('\\n')\n          value = parts[parts.length - 1]\n          value = value.replace(/\\S/g, '')\n          return false\n        }\n      }\n    })\n    return value\n  }\n\n  rawBeforeComment(root, node) {\n    let value\n    root.walkComments(i => {\n      if (typeof i.raws.before !== 'undefined') {\n        value = i.raws.before\n        if (value.includes('\\n')) {\n          value = value.replace(/[^\\n]+$/, '')\n        }\n        return false\n      }\n    })\n    if (typeof value === 'undefined') {\n      value = this.raw(node, null, 'beforeDecl')\n    } else if (value) {\n      value = value.replace(/\\S/g, '')\n    }\n    return value\n  }\n\n  rawBeforeDecl(root, node) {\n    let value\n    root.walkDecls(i => {\n      if (typeof i.raws.before !== 'undefined') {\n        value = i.raws.before\n        if (value.includes('\\n')) {\n          value = value.replace(/[^\\n]+$/, '')\n        }\n        return false\n      }\n    })\n    if (typeof value === 'undefined') {\n      value = this.raw(node, null, 'beforeRule')\n    } else if (value) {\n      value = value.replace(/\\S/g, '')\n    }\n    return value\n  }\n\n  rawBeforeRule(root) {\n    let value\n    root.walk(i => {\n      if (i.nodes && (i.parent !== root || root.first !== i)) {\n        if (typeof i.raws.before !== 'undefined') {\n          value = i.raws.before\n          if (value.includes('\\n')) {\n            value = value.replace(/[^\\n]+$/, '')\n          }\n          return false\n        }\n      }\n    })\n    if (value) value = value.replace(/\\S/g, '')\n    return value\n  }\n\n  rawBeforeClose(root) {\n    let value\n    root.walk(i => {\n      if (i.nodes && i.nodes.length > 0) {\n        if (typeof i.raws.after !== 'undefined') {\n          value = i.raws.after\n          if (value.includes('\\n')) {\n            value = value.replace(/[^\\n]+$/, '')\n          }\n          return false\n        }\n      }\n    })\n    if (value) value = value.replace(/\\S/g, '')\n    return value\n  }\n\n  rawBeforeOpen(root) {\n    let value\n    root.walk(i => {\n      if (i.type !== 'decl') {\n        value = i.raws.between\n        if (typeof value !== 'undefined') return false\n      }\n    })\n    return value\n  }\n\n  rawColon(root) {\n    let value\n    root.walkDecls(i => {\n      if (typeof i.raws.between !== 'undefined') {\n        value = i.raws.between.replace(/[^\\s:]/g, '')\n        return false\n      }\n    })\n    return value\n  }\n\n  beforeAfter(node, detect) {\n    let value\n    if (node.type === 'decl') {\n      value = this.raw(node, null, 'beforeDecl')\n    } else if (node.type === 'comment') {\n      value = this.raw(node, null, 'beforeComment')\n    } else if (detect === 'before') {\n      value = this.raw(node, null, 'beforeRule')\n    } else {\n      value = this.raw(node, null, 'beforeClose')\n    }\n\n    let buf = node.parent\n    let depth = 0\n    while (buf && buf.type !== 'root') {\n      depth += 1\n      buf = buf.parent\n    }\n\n    if (value.includes('\\n')) {\n      let indent = this.raw(node, null, 'indent')\n      if (indent.length) {\n        for (let step = 0; step < depth; step++) value += indent\n      }\n    }\n\n    return value\n  }\n\n  rawValue(node, prop) {\n    let value = node[prop]\n    let raw = node.raws[prop]\n    if (raw && raw.value === value) {\n      return raw.raw\n    }\n\n    return value\n  }\n}\n\nmodule.exports = Stringifier\nStringifier.default = Stringifier\n"]},"metadata":{},"sourceType":"script"}