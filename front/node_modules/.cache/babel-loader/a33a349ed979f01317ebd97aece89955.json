{"ast":null,"code":"\"use strict\"; //\n// Copyright (c) Microsoft. All rights reserved.\n// Licensed under the MIT license. See LICENSE.md file in the project root for full license information.\n//\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ConnectionMessageImpl = exports.ConnectionMessage = void 0;\n\nvar HeaderNames_1 = require(\"../common.speech/HeaderNames\");\n\nvar Exports_1 = require(\"../common/Exports\");\n\nvar PropertyCollection_1 = require(\"./PropertyCollection\");\n\nvar PropertyId_1 = require(\"./PropertyId\");\n/**\n * ConnectionMessage represents implementation specific messages sent to and received from\n * the speech service. These messages are provided for debugging purposes and should not\n * be used for production use cases with the Azure Cognitive Services Speech Service.\n * Messages sent to and received from the Speech Service are subject to change without\n * notice. This includes message contents, headers, payloads, ordering, etc.\n * Added in version 1.11.0.\n */\n\n\nvar ConnectionMessage =\n/** @class */\nfunction () {\n  function ConnectionMessage() {}\n\n  return ConnectionMessage;\n}();\n\nexports.ConnectionMessage = ConnectionMessage; // tslint:disable-next-line:max-classes-per-file\n\nvar ConnectionMessageImpl =\n/** @class */\nfunction () {\n  function ConnectionMessageImpl(message) {\n    var _this = this;\n\n    this.privConnectionMessage = message;\n    this.privProperties = new PropertyCollection_1.PropertyCollection();\n\n    if (!!this.privConnectionMessage.headers[HeaderNames_1.HeaderNames.ConnectionId]) {\n      this.privProperties.setProperty(PropertyId_1.PropertyId.Speech_SessionId, this.privConnectionMessage.headers[HeaderNames_1.HeaderNames.ConnectionId]);\n    }\n\n    Object.keys(this.privConnectionMessage.headers).forEach(function (header, index, array) {\n      _this.privProperties.setProperty(header, _this.privConnectionMessage.headers[header]);\n    });\n  }\n\n  Object.defineProperty(ConnectionMessageImpl.prototype, \"path\", {\n    /**\n     * The message path.\n     */\n    get: function () {\n      return this.privConnectionMessage.headers[Object.keys(this.privConnectionMessage.headers).find(function (key) {\n        return key.toLowerCase() === \"path\".toLowerCase();\n      })];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ConnectionMessageImpl.prototype, \"isTextMessage\", {\n    /**\n     * Checks to see if the ConnectionMessage is a text message.\n     * See also IsBinaryMessage().\n     */\n    get: function () {\n      return this.privConnectionMessage.messageType === Exports_1.MessageType.Text;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ConnectionMessageImpl.prototype, \"isBinaryMessage\", {\n    /**\n     * Checks to see if the ConnectionMessage is a binary message.\n     * See also GetBinaryMessage().\n     */\n    get: function () {\n      return this.privConnectionMessage.messageType === Exports_1.MessageType.Binary;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ConnectionMessageImpl.prototype, \"TextMessage\", {\n    /**\n     * Gets the text message payload. Typically the text message content-type is\n     * application/json. To determine other content-types use\n     * Properties.GetProperty(\"Content-Type\").\n     */\n    get: function () {\n      return this.privConnectionMessage.textBody;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ConnectionMessageImpl.prototype, \"binaryMessage\", {\n    /**\n     * Gets the binary message payload.\n     */\n    get: function () {\n      return this.privConnectionMessage.binaryBody;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ConnectionMessageImpl.prototype, \"properties\", {\n    /**\n     * A collection of properties and their values defined for this <see cref=\"ConnectionMessage\"/>.\n     * Message headers can be accessed via this collection (e.g. \"Content-Type\").\n     */\n    get: function () {\n      return this.privProperties;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Returns a string that represents the connection message.\n   */\n\n  ConnectionMessageImpl.prototype.toString = function () {\n    return \"\";\n  };\n\n  return ConnectionMessageImpl;\n}();\n\nexports.ConnectionMessageImpl = ConnectionMessageImpl;","map":{"version":3,"mappings":"cAAA;AACA;AACA;AACA;;;;;;;AAEA;;AACA;;AAIA;;AAGA;AAEA;;;;;;;;;;AAQA;AAAA;AAAA;AAAA,gCAwCC;;AAAD;AAxCA;;AAAsBA,8C,CA0CtB;;AACA;AAAA;AAAA;AAKI,iCAAYC,OAAZ,EAAyC;AAAzC;;AACI,SAAKC,qBAAL,GAA6BD,OAA7B;AACA,SAAKE,cAAL,GAAsB,IAAIC,uCAAJ,EAAtB;;AACA,QAAI,CAAC,CAAC,KAAKF,qBAAL,CAA2BG,OAA3B,CAAmCC,0BAAYC,YAA/C,CAAN,EAAoE;AAChE,WAAKJ,cAAL,CAAoBK,WAApB,CAAgCC,wBAAWC,gBAA3C,EAA6D,KAAKR,qBAAL,CAA2BG,OAA3B,CAAmCC,0BAAYC,YAA/C,CAA7D;AACH;;AAEDI,UAAM,CAACC,IAAP,CAAY,KAAKV,qBAAL,CAA2BG,OAAvC,EAAgDQ,OAAhD,CAAwD,UAACC,MAAD,EAAiBC,KAAjB,EAAgCC,KAAhC,EAA+C;AACnGC,WAAI,CAACd,cAAL,CAAoBK,WAApB,CAAgCM,MAAhC,EAAwCG,KAAI,CAACf,qBAAL,CAA2BG,OAA3B,CAAmCS,MAAnC,CAAxC;AACH,KAFD;AAGH;;AAKDH,wBAAWO,+BAAX,EAAW,MAAX,EAAe;AAHf;;;SAGA;AACI,aAAO,KAAKhB,qBAAL,CAA2BG,OAA3B,CAAmCM,MAAM,CAACC,IAAP,CAAY,KAAKV,qBAAL,CAA2BG,OAAvC,EAAgDc,IAAhD,CAAqD,UAACC,GAAD,EAAY;AAAK,kBAAG,CAACC,WAAJ,OAAsB,OAAOA,WAAP,EAAtB;AAA0C,OAAhH,CAAnC,CAAP;AACH,KAFc;qBAAA;;AAAA,GAAf;AAQAV,wBAAWO,+BAAX,EAAW,eAAX,EAAwB;AAJxB;;;;SAIA;AACI,aAAO,KAAKhB,qBAAL,CAA2BoB,WAA3B,KAA2CC,sBAAYC,IAA9D;AACH,KAFuB;qBAAA;;AAAA,GAAxB;AAQAb,wBAAWO,+BAAX,EAAW,iBAAX,EAA0B;AAJ1B;;;;SAIA;AACI,aAAO,KAAKhB,qBAAL,CAA2BoB,WAA3B,KAA2CC,sBAAYE,MAA9D;AACH,KAFyB;qBAAA;;AAAA,GAA1B;AASAd,wBAAWO,+BAAX,EAAW,aAAX,EAAsB;AALtB;;;;;SAKA;AACI,aAAO,KAAKhB,qBAAL,CAA2BwB,QAAlC;AACH,KAFqB;qBAAA;;AAAA,GAAtB;AAOAf,wBAAWO,+BAAX,EAAW,eAAX,EAAwB;AAHxB;;;SAGA;AACI,aAAO,KAAKhB,qBAAL,CAA2ByB,UAAlC;AACH,KAFuB;qBAAA;;AAAA,GAAxB;AAQAhB,wBAAWO,+BAAX,EAAW,YAAX,EAAqB;AAJrB;;;;SAIA;AACI,aAAO,KAAKf,cAAZ;AACH,KAFoB;qBAAA;;AAAA,GAArB;AAIA;;;;AAGOe,6CAAP;AACI,WAAO,EAAP;AACH,GAFM;;AAGX;AAtEA;;AAAalB","names":["exports","message","privConnectionMessage","privProperties","PropertyCollection_1","headers","HeaderNames_1","ConnectionId","setProperty","PropertyId_1","Speech_SessionId","Object","keys","forEach","header","index","array","_this","ConnectionMessageImpl","find","key","toLowerCase","messageType","Exports_1","Text","Binary","textBody","binaryBody"],"sources":["/Users/dylanmurray/Sweng-2022/front/node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/src/sdk/ConnectionMessage.ts"],"sourcesContent":["//\r\n// Copyright (c) Microsoft. All rights reserved.\r\n// Licensed under the MIT license. See LICENSE.md file in the project root for full license information.\r\n//\r\n\r\nimport { HeaderNames } from \"../common.speech/HeaderNames\";\r\nimport {\r\n    ConnectionMessage as IntConnectionMessage,\r\n    MessageType\r\n} from \"../common/Exports\";\r\nimport {\r\n    PropertyCollection\r\n} from \"./PropertyCollection\";\r\nimport { PropertyId } from \"./PropertyId\";\r\n\r\n/**\r\n * ConnectionMessage represents implementation specific messages sent to and received from\r\n * the speech service. These messages are provided for debugging purposes and should not\r\n * be used for production use cases with the Azure Cognitive Services Speech Service.\r\n * Messages sent to and received from the Speech Service are subject to change without\r\n * notice. This includes message contents, headers, payloads, ordering, etc.\r\n * Added in version 1.11.0.\r\n */\r\nexport abstract class ConnectionMessage {\r\n    /**\r\n     * The message path.\r\n     */\r\n    public abstract get path(): string;\r\n\r\n    /**\r\n     * Checks to see if the ConnectionMessage is a text message.\r\n     * See also IsBinaryMessage().\r\n     */\r\n    public abstract get isTextMessage(): boolean;\r\n\r\n    /**\r\n     * Checks to see if the ConnectionMessage is a binary message.\r\n     * See also GetBinaryMessage().\r\n     */\r\n    public abstract get isBinaryMessage(): boolean;\r\n\r\n    /**\r\n     * Gets the text message payload. Typically the text message content-type is\r\n     * application/json. To determine other content-types use\r\n     * Properties.GetProperty(\"Content-Type\").\r\n     */\r\n    public abstract get TextMessage(): string;\r\n\r\n    /**\r\n     * Gets the binary message payload.\r\n     */\r\n    public abstract get binaryMessage(): ArrayBuffer;\r\n\r\n    /**\r\n     * A collection of properties and their values defined for this <see cref=\"ConnectionMessage\"/>.\r\n     * Message headers can be accessed via this collection (e.g. \"Content-Type\").\r\n     */\r\n    public abstract get properties(): PropertyCollection;\r\n\r\n    /**\r\n     * Returns a string that represents the connection message.\r\n     */\r\n    public abstract toString(): string;\r\n}\r\n\r\n// tslint:disable-next-line:max-classes-per-file\r\nexport class ConnectionMessageImpl {\r\n\r\n    private privConnectionMessage: IntConnectionMessage;\r\n    private privProperties: PropertyCollection;\r\n\r\n    constructor(message: IntConnectionMessage) {\r\n        this.privConnectionMessage = message;\r\n        this.privProperties = new PropertyCollection();\r\n        if (!!this.privConnectionMessage.headers[HeaderNames.ConnectionId]) {\r\n            this.privProperties.setProperty(PropertyId.Speech_SessionId, this.privConnectionMessage.headers[HeaderNames.ConnectionId]);\r\n        }\r\n\r\n        Object.keys(this.privConnectionMessage.headers).forEach((header: string, index: number, array: string[]): void => {\r\n            this.privProperties.setProperty(header, this.privConnectionMessage.headers[header]);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * The message path.\r\n     */\r\n    public get path(): string {\r\n        return this.privConnectionMessage.headers[Object.keys(this.privConnectionMessage.headers).find((key: string) => key.toLowerCase() === \"path\".toLowerCase())];\r\n    }\r\n\r\n    /**\r\n     * Checks to see if the ConnectionMessage is a text message.\r\n     * See also IsBinaryMessage().\r\n     */\r\n    public get isTextMessage(): boolean {\r\n        return this.privConnectionMessage.messageType === MessageType.Text;\r\n    }\r\n\r\n    /**\r\n     * Checks to see if the ConnectionMessage is a binary message.\r\n     * See also GetBinaryMessage().\r\n     */\r\n    public get isBinaryMessage(): boolean {\r\n        return this.privConnectionMessage.messageType === MessageType.Binary;\r\n    }\r\n\r\n    /**\r\n     * Gets the text message payload. Typically the text message content-type is\r\n     * application/json. To determine other content-types use\r\n     * Properties.GetProperty(\"Content-Type\").\r\n     */\r\n    public get TextMessage(): string {\r\n        return this.privConnectionMessage.textBody;\r\n    }\r\n\r\n    /**\r\n     * Gets the binary message payload.\r\n     */\r\n    public get binaryMessage(): ArrayBuffer {\r\n        return this.privConnectionMessage.binaryBody;\r\n    }\r\n\r\n    /**\r\n     * A collection of properties and their values defined for this <see cref=\"ConnectionMessage\"/>.\r\n     * Message headers can be accessed via this collection (e.g. \"Content-Type\").\r\n     */\r\n    public get properties(): PropertyCollection {\r\n        return this.privProperties;\r\n    }\r\n\r\n    /**\r\n     * Returns a string that represents the connection message.\r\n     */\r\n    public toString(): string {\r\n        return \"\";\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"script"}