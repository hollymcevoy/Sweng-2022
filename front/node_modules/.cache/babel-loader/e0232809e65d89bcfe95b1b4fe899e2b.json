{"ast":null,"code":"const htmlparser = require('htmlparser2');\n\nconst escapeStringRegexp = require('escape-string-regexp');\n\nconst {\n  klona\n} = require('klona');\n\nconst {\n  isPlainObject\n} = require('is-plain-object');\n\nconst deepmerge = require('deepmerge');\n\nconst parseSrcset = require('parse-srcset');\n\nconst {\n  parse: postcssParse\n} = require('postcss'); // Tags that can conceivably represent stand-alone media.\n\n\nconst mediaTags = ['img', 'audio', 'video', 'picture', 'svg', 'object', 'map', 'iframe', 'embed']; // Tags that are inherently vulnerable to being used in XSS attacks.\n\nconst vulnerableTags = ['script', 'style'];\n\nfunction each(obj, cb) {\n  if (obj) {\n    Object.keys(obj).forEach(function (key) {\n      cb(obj[key], key);\n    });\n  }\n} // Avoid false positives with .__proto__, .hasOwnProperty, etc.\n\n\nfunction has(obj, key) {\n  return {}.hasOwnProperty.call(obj, key);\n} // Returns those elements of `a` for which `cb(a)` returns truthy\n\n\nfunction filter(a, cb) {\n  const n = [];\n  each(a, function (v) {\n    if (cb(v)) {\n      n.push(v);\n    }\n  });\n  return n;\n}\n\nfunction isEmptyObject(obj) {\n  for (const key in obj) {\n    if (has(obj, key)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction stringifySrcset(parsedSrcset) {\n  return parsedSrcset.map(function (part) {\n    if (!part.url) {\n      throw new Error('URL missing');\n    }\n\n    return part.url + (part.w ? ` ${part.w}w` : '') + (part.h ? ` ${part.h}h` : '') + (part.d ? ` ${part.d}x` : '');\n  }).join(', ');\n}\n\nmodule.exports = sanitizeHtml; // A valid attribute name.\n// We use a tolerant definition based on the set of strings defined by\n// html.spec.whatwg.org/multipage/parsing.html#before-attribute-name-state\n// and html.spec.whatwg.org/multipage/parsing.html#attribute-name-state .\n// The characters accepted are ones which can be appended to the attribute\n// name buffer without triggering a parse error:\n//   * unexpected-equals-sign-before-attribute-name\n//   * unexpected-null-character\n//   * unexpected-character-in-attribute-name\n// We exclude the empty string because it's impossible to get to the after\n// attribute name state with an empty attribute name buffer.\n\nconst VALID_HTML_ATTRIBUTE_NAME = /^[^\\0\\t\\n\\f\\r /<=>]+$/; // Ignore the _recursing flag; it's there for recursive\n// invocation as a guard against this exploit:\n// https://github.com/fb55/htmlparser2/issues/105\n\nfunction sanitizeHtml(html, options, _recursing) {\n  let result = ''; // Used for hot swapping the result variable with an empty string in order to \"capture\" the text written to it.\n\n  let tempResult = '';\n\n  function Frame(tag, attribs) {\n    const that = this;\n    this.tag = tag;\n    this.attribs = attribs || {};\n    this.tagPosition = result.length;\n    this.text = ''; // Node inner text\n\n    this.mediaChildren = [];\n\n    this.updateParentNodeText = function () {\n      if (stack.length) {\n        const parentFrame = stack[stack.length - 1];\n        parentFrame.text += that.text;\n      }\n    };\n\n    this.updateParentNodeMediaChildren = function () {\n      if (stack.length && mediaTags.includes(this.tag)) {\n        const parentFrame = stack[stack.length - 1];\n        parentFrame.mediaChildren.push(this.tag);\n      }\n    };\n  }\n\n  options = Object.assign({}, sanitizeHtml.defaults, options);\n  options.parser = Object.assign({}, htmlParserDefaults, options.parser); // vulnerableTags\n\n  vulnerableTags.forEach(function (tag) {\n    if (options.allowedTags && options.allowedTags.indexOf(tag) > -1 && !options.allowVulnerableTags) {\n      console.warn(`\\n\\n⚠️ Your \\`allowedTags\\` option includes, \\`${tag}\\`, which is inherently\\nvulnerable to XSS attacks. Please remove it from \\`allowedTags\\`.\\nOr, to disable this warning, add the \\`allowVulnerableTags\\` option\\nand ensure you are accounting for this risk.\\n\\n`);\n    }\n  }); // Tags that contain something other than HTML, or where discarding\n  // the text when the tag is disallowed makes sense for other reasons.\n  // If we are not allowing these tags, we should drop their content too.\n  // For other tags you would drop the tag but keep its content.\n\n  const nonTextTagsArray = options.nonTextTags || ['script', 'style', 'textarea', 'option'];\n  let allowedAttributesMap;\n  let allowedAttributesGlobMap;\n\n  if (options.allowedAttributes) {\n    allowedAttributesMap = {};\n    allowedAttributesGlobMap = {};\n    each(options.allowedAttributes, function (attributes, tag) {\n      allowedAttributesMap[tag] = [];\n      const globRegex = [];\n      attributes.forEach(function (obj) {\n        if (typeof obj === 'string' && obj.indexOf('*') >= 0) {\n          globRegex.push(escapeStringRegexp(obj).replace(/\\\\\\*/g, '.*'));\n        } else {\n          allowedAttributesMap[tag].push(obj);\n        }\n      });\n\n      if (globRegex.length) {\n        allowedAttributesGlobMap[tag] = new RegExp('^(' + globRegex.join('|') + ')$');\n      }\n    });\n  }\n\n  const allowedClassesMap = {};\n  const allowedClassesGlobMap = {};\n  each(options.allowedClasses, function (classes, tag) {\n    // Implicitly allows the class attribute\n    if (allowedAttributesMap) {\n      if (!has(allowedAttributesMap, tag)) {\n        allowedAttributesMap[tag] = [];\n      }\n\n      allowedAttributesMap[tag].push('class');\n    }\n\n    allowedClassesMap[tag] = [];\n    const globRegex = [];\n    classes.forEach(function (obj) {\n      if (typeof obj === 'string' && obj.indexOf('*') >= 0) {\n        globRegex.push(escapeStringRegexp(obj).replace(/\\\\\\*/g, '.*'));\n      } else {\n        allowedClassesMap[tag].push(obj);\n      }\n    });\n\n    if (globRegex.length) {\n      allowedClassesGlobMap[tag] = new RegExp('^(' + globRegex.join('|') + ')$');\n    }\n  });\n  const transformTagsMap = {};\n  let transformTagsAll;\n  each(options.transformTags, function (transform, tag) {\n    let transFun;\n\n    if (typeof transform === 'function') {\n      transFun = transform;\n    } else if (typeof transform === 'string') {\n      transFun = sanitizeHtml.simpleTransform(transform);\n    }\n\n    if (tag === '*') {\n      transformTagsAll = transFun;\n    } else {\n      transformTagsMap[tag] = transFun;\n    }\n  });\n  let depth;\n  let stack;\n  let skipMap;\n  let transformMap;\n  let skipText;\n  let skipTextDepth;\n  let addedText = false;\n  initializeState();\n  const parser = new htmlparser.Parser({\n    onopentag: function (name, attribs) {\n      // If `enforceHtmlBoundary` is `true` and this has found the opening\n      // `html` tag, reset the state.\n      if (options.enforceHtmlBoundary && name === 'html') {\n        initializeState();\n      }\n\n      if (skipText) {\n        skipTextDepth++;\n        return;\n      }\n\n      const frame = new Frame(name, attribs);\n      stack.push(frame);\n      let skip = false;\n      const hasText = !!frame.text;\n      let transformedTag;\n\n      if (has(transformTagsMap, name)) {\n        transformedTag = transformTagsMap[name](name, attribs);\n        frame.attribs = attribs = transformedTag.attribs;\n\n        if (transformedTag.text !== undefined) {\n          frame.innerText = transformedTag.text;\n        }\n\n        if (name !== transformedTag.tagName) {\n          frame.name = name = transformedTag.tagName;\n          transformMap[depth] = transformedTag.tagName;\n        }\n      }\n\n      if (transformTagsAll) {\n        transformedTag = transformTagsAll(name, attribs);\n        frame.attribs = attribs = transformedTag.attribs;\n\n        if (name !== transformedTag.tagName) {\n          frame.name = name = transformedTag.tagName;\n          transformMap[depth] = transformedTag.tagName;\n        }\n      }\n\n      if (options.allowedTags && options.allowedTags.indexOf(name) === -1 || options.disallowedTagsMode === 'recursiveEscape' && !isEmptyObject(skipMap) || options.nestingLimit != null && depth >= options.nestingLimit) {\n        skip = true;\n        skipMap[depth] = true;\n\n        if (options.disallowedTagsMode === 'discard') {\n          if (nonTextTagsArray.indexOf(name) !== -1) {\n            skipText = true;\n            skipTextDepth = 1;\n          }\n        }\n\n        skipMap[depth] = true;\n      }\n\n      depth++;\n\n      if (skip) {\n        if (options.disallowedTagsMode === 'discard') {\n          // We want the contents but not this tag\n          return;\n        }\n\n        tempResult = result;\n        result = '';\n      }\n\n      result += '<' + name;\n\n      if (!allowedAttributesMap || has(allowedAttributesMap, name) || allowedAttributesMap['*']) {\n        each(attribs, function (value, a) {\n          if (!VALID_HTML_ATTRIBUTE_NAME.test(a)) {\n            // This prevents part of an attribute name in the output from being\n            // interpreted as the end of an attribute, or end of a tag.\n            delete frame.attribs[a];\n            return;\n          }\n\n          let parsed; // check allowedAttributesMap for the element and attribute and modify the value\n          // as necessary if there are specific values defined.\n\n          let passedAllowedAttributesMapCheck = false;\n\n          if (!allowedAttributesMap || has(allowedAttributesMap, name) && allowedAttributesMap[name].indexOf(a) !== -1 || allowedAttributesMap['*'] && allowedAttributesMap['*'].indexOf(a) !== -1 || has(allowedAttributesGlobMap, name) && allowedAttributesGlobMap[name].test(a) || allowedAttributesGlobMap['*'] && allowedAttributesGlobMap['*'].test(a)) {\n            passedAllowedAttributesMapCheck = true;\n          } else if (allowedAttributesMap && allowedAttributesMap[name]) {\n            for (const o of allowedAttributesMap[name]) {\n              if (isPlainObject(o) && o.name && o.name === a) {\n                passedAllowedAttributesMapCheck = true;\n                let newValue = '';\n\n                if (o.multiple === true) {\n                  // verify the values that are allowed\n                  const splitStrArray = value.split(' ');\n\n                  for (const s of splitStrArray) {\n                    if (o.values.indexOf(s) !== -1) {\n                      if (newValue === '') {\n                        newValue = s;\n                      } else {\n                        newValue += ' ' + s;\n                      }\n                    }\n                  }\n                } else if (o.values.indexOf(value) >= 0) {\n                  // verified an allowed value matches the entire attribute value\n                  newValue = value;\n                }\n\n                value = newValue;\n              }\n            }\n          }\n\n          if (passedAllowedAttributesMapCheck) {\n            if (options.allowedSchemesAppliedToAttributes.indexOf(a) !== -1) {\n              if (naughtyHref(name, value)) {\n                delete frame.attribs[a];\n                return;\n              }\n            }\n\n            if (name === 'iframe' && a === 'src') {\n              let allowed = true;\n\n              try {\n                // Chrome accepts \\ as a substitute for / in the // at the\n                // start of a URL, so rewrite accordingly to prevent exploit.\n                // Also drop any whitespace at that point in the URL\n                value = value.replace(/^(\\w+:)?\\s*[\\\\/]\\s*[\\\\/]/, '$1//');\n\n                if (value.startsWith('relative:')) {\n                  // An attempt to exploit our workaround for base URLs being\n                  // mandatory for relative URL validation in the WHATWG\n                  // URL parser, reject it\n                  throw new Error('relative: exploit attempt');\n                } // naughtyHref is in charge of whether protocol relative URLs\n                // are cool. Here we are concerned just with allowed hostnames and\n                // whether to allow relative URLs.\n                //\n                // Build a placeholder \"base URL\" against which any reasonable\n                // relative URL may be parsed successfully\n\n\n                let base = 'relative://relative-site';\n\n                for (let i = 0; i < 100; i++) {\n                  base += `/${i}`;\n                }\n\n                const parsed = new URL(value, base);\n                const isRelativeUrl = parsed && parsed.hostname === 'relative-site' && parsed.protocol === 'relative:';\n\n                if (isRelativeUrl) {\n                  // default value of allowIframeRelativeUrls is true\n                  // unless allowedIframeHostnames or allowedIframeDomains specified\n                  allowed = has(options, 'allowIframeRelativeUrls') ? options.allowIframeRelativeUrls : !options.allowedIframeHostnames && !options.allowedIframeDomains;\n                } else if (options.allowedIframeHostnames || options.allowedIframeDomains) {\n                  const allowedHostname = (options.allowedIframeHostnames || []).find(function (hostname) {\n                    return hostname === parsed.hostname;\n                  });\n                  const allowedDomain = (options.allowedIframeDomains || []).find(function (domain) {\n                    return parsed.hostname === domain || parsed.hostname.endsWith(`.${domain}`);\n                  });\n                  allowed = allowedHostname || allowedDomain;\n                }\n              } catch (e) {\n                // Unparseable iframe src\n                allowed = false;\n              }\n\n              if (!allowed) {\n                delete frame.attribs[a];\n                return;\n              }\n            }\n\n            if (a === 'srcset') {\n              try {\n                parsed = parseSrcset(value);\n                parsed.forEach(function (value) {\n                  if (naughtyHref('srcset', value.url)) {\n                    value.evil = true;\n                  }\n                });\n                parsed = filter(parsed, function (v) {\n                  return !v.evil;\n                });\n\n                if (!parsed.length) {\n                  delete frame.attribs[a];\n                  return;\n                } else {\n                  value = stringifySrcset(filter(parsed, function (v) {\n                    return !v.evil;\n                  }));\n                  frame.attribs[a] = value;\n                }\n              } catch (e) {\n                // Unparseable srcset\n                delete frame.attribs[a];\n                return;\n              }\n            }\n\n            if (a === 'class') {\n              const allowedSpecificClasses = allowedClassesMap[name];\n              const allowedWildcardClasses = allowedClassesMap['*'];\n              const allowedSpecificClassesGlob = allowedClassesGlobMap[name];\n              const allowedWildcardClassesGlob = allowedClassesGlobMap['*'];\n              const allowedClassesGlobs = [allowedSpecificClassesGlob, allowedWildcardClassesGlob].filter(function (t) {\n                return t;\n              });\n\n              if (allowedSpecificClasses && allowedWildcardClasses) {\n                value = filterClasses(value, deepmerge(allowedSpecificClasses, allowedWildcardClasses), allowedClassesGlobs);\n              } else {\n                value = filterClasses(value, allowedSpecificClasses || allowedWildcardClasses, allowedClassesGlobs);\n              }\n\n              if (!value.length) {\n                delete frame.attribs[a];\n                return;\n              }\n            }\n\n            if (a === 'style') {\n              try {\n                const abstractSyntaxTree = postcssParse(name + ' {' + value + '}');\n                const filteredAST = filterCss(abstractSyntaxTree, options.allowedStyles);\n                value = stringifyStyleAttributes(filteredAST);\n\n                if (value.length === 0) {\n                  delete frame.attribs[a];\n                  return;\n                }\n              } catch (e) {\n                delete frame.attribs[a];\n                return;\n              }\n            }\n\n            result += ' ' + a;\n\n            if (value && value.length) {\n              result += '=\"' + escapeHtml(value, true) + '\"';\n            }\n          } else {\n            delete frame.attribs[a];\n          }\n        });\n      }\n\n      if (options.selfClosing.indexOf(name) !== -1) {\n        result += ' />';\n      } else {\n        result += '>';\n\n        if (frame.innerText && !hasText && !options.textFilter) {\n          result += escapeHtml(frame.innerText);\n          addedText = true;\n        }\n      }\n\n      if (skip) {\n        result = tempResult + escapeHtml(result);\n        tempResult = '';\n      }\n    },\n    ontext: function (text) {\n      if (skipText) {\n        return;\n      }\n\n      const lastFrame = stack[stack.length - 1];\n      let tag;\n\n      if (lastFrame) {\n        tag = lastFrame.tag; // If inner text was set by transform function then let's use it\n\n        text = lastFrame.innerText !== undefined ? lastFrame.innerText : text;\n      }\n\n      if (options.disallowedTagsMode === 'discard' && (tag === 'script' || tag === 'style')) {\n        // htmlparser2 gives us these as-is. Escaping them ruins the content. Allowing\n        // script tags is, by definition, game over for XSS protection, so if that's\n        // your concern, don't allow them. The same is essentially true for style tags\n        // which have their own collection of XSS vectors.\n        result += text;\n      } else {\n        const escaped = escapeHtml(text, false);\n\n        if (options.textFilter && !addedText) {\n          result += options.textFilter(escaped, tag);\n        } else if (!addedText) {\n          result += escaped;\n        }\n      }\n\n      if (stack.length) {\n        const frame = stack[stack.length - 1];\n        frame.text += text;\n      }\n    },\n    onclosetag: function (name) {\n      if (skipText) {\n        skipTextDepth--;\n\n        if (!skipTextDepth) {\n          skipText = false;\n        } else {\n          return;\n        }\n      }\n\n      const frame = stack.pop();\n\n      if (!frame) {\n        // Do not crash on bad markup\n        return;\n      }\n\n      skipText = options.enforceHtmlBoundary ? name === 'html' : false;\n      depth--;\n      const skip = skipMap[depth];\n\n      if (skip) {\n        delete skipMap[depth];\n\n        if (options.disallowedTagsMode === 'discard') {\n          frame.updateParentNodeText();\n          return;\n        }\n\n        tempResult = result;\n        result = '';\n      }\n\n      if (transformMap[depth]) {\n        name = transformMap[depth];\n        delete transformMap[depth];\n      }\n\n      if (options.exclusiveFilter && options.exclusiveFilter(frame)) {\n        result = result.substr(0, frame.tagPosition);\n        return;\n      }\n\n      frame.updateParentNodeMediaChildren();\n      frame.updateParentNodeText();\n\n      if (options.selfClosing.indexOf(name) !== -1) {\n        // Already output />\n        if (skip) {\n          result = tempResult;\n          tempResult = '';\n        }\n\n        return;\n      }\n\n      result += '</' + name + '>';\n\n      if (skip) {\n        result = tempResult + escapeHtml(result);\n        tempResult = '';\n      }\n    }\n  }, options.parser);\n  parser.write(html);\n  parser.end();\n  return result;\n\n  function initializeState() {\n    result = '';\n    depth = 0;\n    stack = [];\n    skipMap = {};\n    transformMap = {};\n    skipText = false;\n    skipTextDepth = 0;\n  }\n\n  function escapeHtml(s, quote) {\n    if (typeof s !== 'string') {\n      s = s + '';\n    }\n\n    if (options.parser.decodeEntities) {\n      s = s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');\n\n      if (quote) {\n        s = s.replace(/\"/g, '&quot;');\n      }\n    } // TODO: this is inadequate because it will pass `&0;`. This approach\n    // will not work, each & must be considered with regard to whether it\n    // is followed by a 100% syntactically valid entity or not, and escaped\n    // if it is not. If this bothers you, don't set parser.decodeEntities\n    // to false. (The default is true.)\n\n\n    s = s.replace(/&(?![a-zA-Z0-9#]{1,20};)/g, '&amp;') // Match ampersands not part of existing HTML entity\n    .replace(/</g, '&lt;').replace(/>/g, '&gt;');\n\n    if (quote) {\n      s = s.replace(/\"/g, '&quot;');\n    }\n\n    return s;\n  }\n\n  function naughtyHref(name, href) {\n    // Browsers ignore character codes of 32 (space) and below in a surprising\n    // number of situations. Start reading here:\n    // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet#Embedded_tab\n    // eslint-disable-next-line no-control-regex\n    href = href.replace(/[\\x00-\\x20]+/g, ''); // Clobber any comments in URLs, which the browser might\n    // interpret inside an XML data island, allowing\n    // a javascript: URL to be snuck through\n\n    href = href.replace(/<!--.*?-->/g, ''); // Case insensitive so we don't get faked out by JAVASCRIPT #1\n    // Allow more characters after the first so we don't get faked\n    // out by certain schemes browsers accept\n\n    const matches = href.match(/^([a-zA-Z][a-zA-Z0-9.\\-+]*):/);\n\n    if (!matches) {\n      // Protocol-relative URL starting with any combination of '/' and '\\'\n      if (href.match(/^[/\\\\]{2}/)) {\n        return !options.allowProtocolRelative;\n      } // No scheme\n\n\n      return false;\n    }\n\n    const scheme = matches[1].toLowerCase();\n\n    if (has(options.allowedSchemesByTag, name)) {\n      return options.allowedSchemesByTag[name].indexOf(scheme) === -1;\n    }\n\n    return !options.allowedSchemes || options.allowedSchemes.indexOf(scheme) === -1;\n  }\n  /**\n   * Filters user input css properties by whitelisted regex attributes.\n   *\n   * @param {object} abstractSyntaxTree  - Object representation of CSS attributes.\n   * @property {array[Declaration]} abstractSyntaxTree.nodes[0] - Each object cointains prop and value key, i.e { prop: 'color', value: 'red' }.\n   * @param {object} allowedStyles       - Keys are properties (i.e color), value is list of permitted regex rules (i.e /green/i).\n   * @return {object}                    - Abstract Syntax Tree with filtered style attributes.\n   */\n\n\n  function filterCss(abstractSyntaxTree, allowedStyles) {\n    if (!allowedStyles) {\n      return abstractSyntaxTree;\n    }\n\n    const filteredAST = klona(abstractSyntaxTree);\n    const astRules = abstractSyntaxTree.nodes[0];\n    let selectedRule; // Merge global and tag-specific styles into new AST.\n\n    if (allowedStyles[astRules.selector] && allowedStyles['*']) {\n      selectedRule = deepmerge(allowedStyles[astRules.selector], allowedStyles['*']);\n    } else {\n      selectedRule = allowedStyles[astRules.selector] || allowedStyles['*'];\n    }\n\n    if (selectedRule) {\n      filteredAST.nodes[0].nodes = astRules.nodes.reduce(filterDeclarations(selectedRule), []);\n    }\n\n    return filteredAST;\n  }\n  /**\n   * Extracts the style attribues from an AbstractSyntaxTree and formats those\n   * values in the inline style attribute format.\n   *\n   * @param  {AbstractSyntaxTree} filteredAST\n   * @return {string}             - Example: \"color:yellow;text-align:center;font-family:helvetica;\"\n   */\n\n\n  function stringifyStyleAttributes(filteredAST) {\n    return filteredAST.nodes[0].nodes.reduce(function (extractedAttributes, attributeObject) {\n      extractedAttributes.push(attributeObject.prop + ':' + attributeObject.value);\n      return extractedAttributes;\n    }, []).join(';');\n  }\n  /**\n    * Filters the existing attributes for the given property. Discards any attributes\n    * which don't match the whitelist.\n    *\n    * @param  {object} selectedRule             - Example: { color: red, font-family: helvetica }\n    * @param  {array} allowedDeclarationsList   - List of declarations which pass whitelisting.\n    * @param  {object} attributeObject          - Object representing the current css property.\n    * @property {string} attributeObject.type   - Typically 'declaration'.\n    * @property {string} attributeObject.prop   - The CSS property, i.e 'color'.\n    * @property {string} attributeObject.value  - The corresponding value to the css property, i.e 'red'.\n    * @return {function}                        - When used in Array.reduce, will return an array of Declaration objects\n    */\n\n\n  function filterDeclarations(selectedRule) {\n    return function (allowedDeclarationsList, attributeObject) {\n      // If this property is whitelisted...\n      if (has(selectedRule, attributeObject.prop)) {\n        const matchesRegex = selectedRule[attributeObject.prop].some(function (regularExpression) {\n          return regularExpression.test(attributeObject.value);\n        });\n\n        if (matchesRegex) {\n          allowedDeclarationsList.push(attributeObject);\n        }\n      }\n\n      return allowedDeclarationsList;\n    };\n  }\n\n  function filterClasses(classes, allowed, allowedGlobs) {\n    if (!allowed) {\n      // The class attribute is allowed without filtering on this tag\n      return classes;\n    }\n\n    classes = classes.split(/\\s+/);\n    return classes.filter(function (clss) {\n      return allowed.indexOf(clss) !== -1 || allowedGlobs.some(function (glob) {\n        return glob.test(clss);\n      });\n    }).join(' ');\n  }\n} // Defaults are accessible to you so that you can use them as a starting point\n// programmatically if you wish\n\n\nconst htmlParserDefaults = {\n  decodeEntities: true\n};\nsanitizeHtml.defaults = {\n  allowedTags: [// Sections derived from MDN element categories and limited to the more\n  // benign categories.\n  // https://developer.mozilla.org/en-US/docs/Web/HTML/Element\n  // Content sectioning\n  'address', 'article', 'aside', 'footer', 'header', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'hgroup', 'main', 'nav', 'section', // Text content\n  'blockquote', 'dd', 'div', 'dl', 'dt', 'figcaption', 'figure', 'hr', 'li', 'main', 'ol', 'p', 'pre', 'ul', // Inline text semantics\n  'a', 'abbr', 'b', 'bdi', 'bdo', 'br', 'cite', 'code', 'data', 'dfn', 'em', 'i', 'kbd', 'mark', 'q', 'rb', 'rp', 'rt', 'rtc', 'ruby', 's', 'samp', 'small', 'span', 'strong', 'sub', 'sup', 'time', 'u', 'var', 'wbr', // Table content\n  'caption', 'col', 'colgroup', 'table', 'tbody', 'td', 'tfoot', 'th', 'thead', 'tr'],\n  disallowedTagsMode: 'discard',\n  allowedAttributes: {\n    a: ['href', 'name', 'target'],\n    // We don't currently allow img itself by default, but this\n    // would make sense if we did. You could add srcset here,\n    // and if you do the URL is checked for safety\n    img: ['src']\n  },\n  // Lots of these won't come up by default because we don't allow them\n  selfClosing: ['img', 'br', 'hr', 'area', 'base', 'basefont', 'input', 'link', 'meta'],\n  // URL schemes we permit\n  allowedSchemes: ['http', 'https', 'ftp', 'mailto', 'tel'],\n  allowedSchemesByTag: {},\n  allowedSchemesAppliedToAttributes: ['href', 'src', 'cite'],\n  allowProtocolRelative: true,\n  enforceHtmlBoundary: false\n};\n\nsanitizeHtml.simpleTransform = function (newTagName, newAttribs, merge) {\n  merge = merge === undefined ? true : merge;\n  newAttribs = newAttribs || {};\n  return function (tagName, attribs) {\n    let attrib;\n\n    if (merge) {\n      for (attrib in newAttribs) {\n        attribs[attrib] = newAttribs[attrib];\n      }\n    } else {\n      attribs = newAttribs;\n    }\n\n    return {\n      tagName: newTagName,\n      attribs: attribs\n    };\n  };\n};","map":{"version":3,"sources":["/Users/dylanmurray/Sweng-2022/front/node_modules/sanitize-html/index.js"],"names":["htmlparser","require","escapeStringRegexp","klona","isPlainObject","deepmerge","parseSrcset","parse","postcssParse","mediaTags","vulnerableTags","each","obj","cb","Object","keys","forEach","key","has","hasOwnProperty","call","filter","a","n","v","push","isEmptyObject","stringifySrcset","parsedSrcset","map","part","url","Error","w","h","d","join","module","exports","sanitizeHtml","VALID_HTML_ATTRIBUTE_NAME","html","options","_recursing","result","tempResult","Frame","tag","attribs","that","tagPosition","length","text","mediaChildren","updateParentNodeText","stack","parentFrame","updateParentNodeMediaChildren","includes","assign","defaults","parser","htmlParserDefaults","allowedTags","indexOf","allowVulnerableTags","console","warn","nonTextTagsArray","nonTextTags","allowedAttributesMap","allowedAttributesGlobMap","allowedAttributes","attributes","globRegex","replace","RegExp","allowedClassesMap","allowedClassesGlobMap","allowedClasses","classes","transformTagsMap","transformTagsAll","transformTags","transform","transFun","simpleTransform","depth","skipMap","transformMap","skipText","skipTextDepth","addedText","initializeState","Parser","onopentag","name","enforceHtmlBoundary","frame","skip","hasText","transformedTag","undefined","innerText","tagName","disallowedTagsMode","nestingLimit","value","test","parsed","passedAllowedAttributesMapCheck","o","newValue","multiple","splitStrArray","split","s","values","allowedSchemesAppliedToAttributes","naughtyHref","allowed","startsWith","base","i","URL","isRelativeUrl","hostname","protocol","allowIframeRelativeUrls","allowedIframeHostnames","allowedIframeDomains","allowedHostname","find","allowedDomain","domain","endsWith","e","evil","allowedSpecificClasses","allowedWildcardClasses","allowedSpecificClassesGlob","allowedWildcardClassesGlob","allowedClassesGlobs","t","filterClasses","abstractSyntaxTree","filteredAST","filterCss","allowedStyles","stringifyStyleAttributes","escapeHtml","selfClosing","textFilter","ontext","lastFrame","escaped","onclosetag","pop","exclusiveFilter","substr","write","end","quote","decodeEntities","href","matches","match","allowProtocolRelative","scheme","toLowerCase","allowedSchemesByTag","allowedSchemes","astRules","nodes","selectedRule","selector","reduce","filterDeclarations","extractedAttributes","attributeObject","prop","allowedDeclarationsList","matchesRegex","some","regularExpression","allowedGlobs","clss","glob","img","newTagName","newAttribs","merge","attrib"],"mappings":"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","sourcesContent":["const htmlparser = require('htmlparser2');\nconst escapeStringRegexp = require('escape-string-regexp');\nconst { klona } = require('klona');\nconst { isPlainObject } = require('is-plain-object');\nconst deepmerge = require('deepmerge');\nconst parseSrcset = require('parse-srcset');\nconst { parse: postcssParse } = require('postcss');\n// Tags that can conceivably represent stand-alone media.\nconst mediaTags = [\n  'img', 'audio', 'video', 'picture', 'svg',\n  'object', 'map', 'iframe', 'embed'\n];\n// Tags that are inherently vulnerable to being used in XSS attacks.\nconst vulnerableTags = [ 'script', 'style' ];\n\nfunction each(obj, cb) {\n  if (obj) {\n    Object.keys(obj).forEach(function (key) {\n      cb(obj[key], key);\n    });\n  }\n}\n\n// Avoid false positives with .__proto__, .hasOwnProperty, etc.\nfunction has(obj, key) {\n  return ({}).hasOwnProperty.call(obj, key);\n}\n\n// Returns those elements of `a` for which `cb(a)` returns truthy\nfunction filter(a, cb) {\n  const n = [];\n  each(a, function(v) {\n    if (cb(v)) {\n      n.push(v);\n    }\n  });\n  return n;\n}\n\nfunction isEmptyObject(obj) {\n  for (const key in obj) {\n    if (has(obj, key)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction stringifySrcset(parsedSrcset) {\n  return parsedSrcset.map(function(part) {\n    if (!part.url) {\n      throw new Error('URL missing');\n    }\n\n    return (\n      part.url +\n      (part.w ? ` ${part.w}w` : '') +\n      (part.h ? ` ${part.h}h` : '') +\n      (part.d ? ` ${part.d}x` : '')\n    );\n  }).join(', ');\n}\n\nmodule.exports = sanitizeHtml;\n\n// A valid attribute name.\n// We use a tolerant definition based on the set of strings defined by\n// html.spec.whatwg.org/multipage/parsing.html#before-attribute-name-state\n// and html.spec.whatwg.org/multipage/parsing.html#attribute-name-state .\n// The characters accepted are ones which can be appended to the attribute\n// name buffer without triggering a parse error:\n//   * unexpected-equals-sign-before-attribute-name\n//   * unexpected-null-character\n//   * unexpected-character-in-attribute-name\n// We exclude the empty string because it's impossible to get to the after\n// attribute name state with an empty attribute name buffer.\nconst VALID_HTML_ATTRIBUTE_NAME = /^[^\\0\\t\\n\\f\\r /<=>]+$/;\n\n// Ignore the _recursing flag; it's there for recursive\n// invocation as a guard against this exploit:\n// https://github.com/fb55/htmlparser2/issues/105\n\nfunction sanitizeHtml(html, options, _recursing) {\n  let result = '';\n  // Used for hot swapping the result variable with an empty string in order to \"capture\" the text written to it.\n  let tempResult = '';\n\n  function Frame(tag, attribs) {\n    const that = this;\n    this.tag = tag;\n    this.attribs = attribs || {};\n    this.tagPosition = result.length;\n    this.text = ''; // Node inner text\n    this.mediaChildren = [];\n\n    this.updateParentNodeText = function() {\n      if (stack.length) {\n        const parentFrame = stack[stack.length - 1];\n        parentFrame.text += that.text;\n      }\n    };\n\n    this.updateParentNodeMediaChildren = function() {\n      if (stack.length && mediaTags.includes(this.tag)) {\n        const parentFrame = stack[stack.length - 1];\n        parentFrame.mediaChildren.push(this.tag);\n      }\n    };\n  }\n\n  options = Object.assign({}, sanitizeHtml.defaults, options);\n  options.parser = Object.assign({}, htmlParserDefaults, options.parser);\n\n  // vulnerableTags\n  vulnerableTags.forEach(function (tag) {\n    if (\n      options.allowedTags && options.allowedTags.indexOf(tag) > -1 &&\n      !options.allowVulnerableTags\n    ) {\n      console.warn(`\\n\\n⚠️ Your \\`allowedTags\\` option includes, \\`${tag}\\`, which is inherently\\nvulnerable to XSS attacks. Please remove it from \\`allowedTags\\`.\\nOr, to disable this warning, add the \\`allowVulnerableTags\\` option\\nand ensure you are accounting for this risk.\\n\\n`);\n    }\n  });\n\n  // Tags that contain something other than HTML, or where discarding\n  // the text when the tag is disallowed makes sense for other reasons.\n  // If we are not allowing these tags, we should drop their content too.\n  // For other tags you would drop the tag but keep its content.\n  const nonTextTagsArray = options.nonTextTags || [\n    'script',\n    'style',\n    'textarea',\n    'option'\n  ];\n  let allowedAttributesMap;\n  let allowedAttributesGlobMap;\n  if (options.allowedAttributes) {\n    allowedAttributesMap = {};\n    allowedAttributesGlobMap = {};\n    each(options.allowedAttributes, function(attributes, tag) {\n      allowedAttributesMap[tag] = [];\n      const globRegex = [];\n      attributes.forEach(function(obj) {\n        if (typeof obj === 'string' && obj.indexOf('*') >= 0) {\n          globRegex.push(escapeStringRegexp(obj).replace(/\\\\\\*/g, '.*'));\n        } else {\n          allowedAttributesMap[tag].push(obj);\n        }\n      });\n      if (globRegex.length) {\n        allowedAttributesGlobMap[tag] = new RegExp('^(' + globRegex.join('|') + ')$');\n      }\n    });\n  }\n  const allowedClassesMap = {};\n  const allowedClassesGlobMap = {};\n  each(options.allowedClasses, function(classes, tag) {\n    // Implicitly allows the class attribute\n    if (allowedAttributesMap) {\n      if (!has(allowedAttributesMap, tag)) {\n        allowedAttributesMap[tag] = [];\n      }\n      allowedAttributesMap[tag].push('class');\n    }\n\n    allowedClassesMap[tag] = [];\n    const globRegex = [];\n    classes.forEach(function(obj) {\n      if (typeof obj === 'string' && obj.indexOf('*') >= 0) {\n        globRegex.push(escapeStringRegexp(obj).replace(/\\\\\\*/g, '.*'));\n      } else {\n        allowedClassesMap[tag].push(obj);\n      }\n    });\n    if (globRegex.length) {\n      allowedClassesGlobMap[tag] = new RegExp('^(' + globRegex.join('|') + ')$');\n    }\n  });\n\n  const transformTagsMap = {};\n  let transformTagsAll;\n  each(options.transformTags, function(transform, tag) {\n    let transFun;\n    if (typeof transform === 'function') {\n      transFun = transform;\n    } else if (typeof transform === 'string') {\n      transFun = sanitizeHtml.simpleTransform(transform);\n    }\n    if (tag === '*') {\n      transformTagsAll = transFun;\n    } else {\n      transformTagsMap[tag] = transFun;\n    }\n  });\n\n  let depth;\n  let stack;\n  let skipMap;\n  let transformMap;\n  let skipText;\n  let skipTextDepth;\n  let addedText = false;\n\n  initializeState();\n\n  const parser = new htmlparser.Parser({\n    onopentag: function(name, attribs) {\n      // If `enforceHtmlBoundary` is `true` and this has found the opening\n      // `html` tag, reset the state.\n      if (options.enforceHtmlBoundary && name === 'html') {\n        initializeState();\n      }\n\n      if (skipText) {\n        skipTextDepth++;\n        return;\n      }\n      const frame = new Frame(name, attribs);\n      stack.push(frame);\n\n      let skip = false;\n      const hasText = !!frame.text;\n      let transformedTag;\n      if (has(transformTagsMap, name)) {\n        transformedTag = transformTagsMap[name](name, attribs);\n\n        frame.attribs = attribs = transformedTag.attribs;\n\n        if (transformedTag.text !== undefined) {\n          frame.innerText = transformedTag.text;\n        }\n\n        if (name !== transformedTag.tagName) {\n          frame.name = name = transformedTag.tagName;\n          transformMap[depth] = transformedTag.tagName;\n        }\n      }\n      if (transformTagsAll) {\n        transformedTag = transformTagsAll(name, attribs);\n\n        frame.attribs = attribs = transformedTag.attribs;\n        if (name !== transformedTag.tagName) {\n          frame.name = name = transformedTag.tagName;\n          transformMap[depth] = transformedTag.tagName;\n        }\n      }\n\n      if ((options.allowedTags && options.allowedTags.indexOf(name) === -1) || (options.disallowedTagsMode === 'recursiveEscape' && !isEmptyObject(skipMap)) || (options.nestingLimit != null && depth >= options.nestingLimit)) {\n        skip = true;\n        skipMap[depth] = true;\n        if (options.disallowedTagsMode === 'discard') {\n          if (nonTextTagsArray.indexOf(name) !== -1) {\n            skipText = true;\n            skipTextDepth = 1;\n          }\n        }\n        skipMap[depth] = true;\n      }\n      depth++;\n      if (skip) {\n        if (options.disallowedTagsMode === 'discard') {\n          // We want the contents but not this tag\n          return;\n        }\n        tempResult = result;\n        result = '';\n      }\n      result += '<' + name;\n      if (!allowedAttributesMap || has(allowedAttributesMap, name) || allowedAttributesMap['*']) {\n        each(attribs, function(value, a) {\n          if (!VALID_HTML_ATTRIBUTE_NAME.test(a)) {\n            // This prevents part of an attribute name in the output from being\n            // interpreted as the end of an attribute, or end of a tag.\n            delete frame.attribs[a];\n            return;\n          }\n          let parsed;\n          // check allowedAttributesMap for the element and attribute and modify the value\n          // as necessary if there are specific values defined.\n          let passedAllowedAttributesMapCheck = false;\n          if (!allowedAttributesMap ||\n            (has(allowedAttributesMap, name) && allowedAttributesMap[name].indexOf(a) !== -1) ||\n            (allowedAttributesMap['*'] && allowedAttributesMap['*'].indexOf(a) !== -1) ||\n            (has(allowedAttributesGlobMap, name) && allowedAttributesGlobMap[name].test(a)) ||\n            (allowedAttributesGlobMap['*'] && allowedAttributesGlobMap['*'].test(a))) {\n            passedAllowedAttributesMapCheck = true;\n          } else if (allowedAttributesMap && allowedAttributesMap[name]) {\n            for (const o of allowedAttributesMap[name]) {\n              if (isPlainObject(o) && o.name && (o.name === a)) {\n                passedAllowedAttributesMapCheck = true;\n                let newValue = '';\n                if (o.multiple === true) {\n                  // verify the values that are allowed\n                  const splitStrArray = value.split(' ');\n                  for (const s of splitStrArray) {\n                    if (o.values.indexOf(s) !== -1) {\n                      if (newValue === '') {\n                        newValue = s;\n                      } else {\n                        newValue += ' ' + s;\n                      }\n                    }\n                  }\n                } else if (o.values.indexOf(value) >= 0) {\n                  // verified an allowed value matches the entire attribute value\n                  newValue = value;\n                }\n                value = newValue;\n              }\n            }\n          }\n          if (passedAllowedAttributesMapCheck) {\n            if (options.allowedSchemesAppliedToAttributes.indexOf(a) !== -1) {\n              if (naughtyHref(name, value)) {\n                delete frame.attribs[a];\n                return;\n              }\n            }\n            if (name === 'iframe' && a === 'src') {\n              let allowed = true;\n              try {\n                // Chrome accepts \\ as a substitute for / in the // at the\n                // start of a URL, so rewrite accordingly to prevent exploit.\n                // Also drop any whitespace at that point in the URL\n                value = value.replace(/^(\\w+:)?\\s*[\\\\/]\\s*[\\\\/]/, '$1//');\n                if (value.startsWith('relative:')) {\n                  // An attempt to exploit our workaround for base URLs being\n                  // mandatory for relative URL validation in the WHATWG\n                  // URL parser, reject it\n                  throw new Error('relative: exploit attempt');\n                }\n                // naughtyHref is in charge of whether protocol relative URLs\n                // are cool. Here we are concerned just with allowed hostnames and\n                // whether to allow relative URLs.\n                //\n                // Build a placeholder \"base URL\" against which any reasonable\n                // relative URL may be parsed successfully\n                let base = 'relative://relative-site';\n                for (let i = 0; (i < 100); i++) {\n                  base += `/${i}`;\n                }\n                const parsed = new URL(value, base);\n                const isRelativeUrl = parsed && parsed.hostname === 'relative-site' && parsed.protocol === 'relative:';\n                if (isRelativeUrl) {\n                  // default value of allowIframeRelativeUrls is true\n                  // unless allowedIframeHostnames or allowedIframeDomains specified\n                  allowed = has(options, 'allowIframeRelativeUrls')\n                    ? options.allowIframeRelativeUrls\n                    : (!options.allowedIframeHostnames && !options.allowedIframeDomains);\n                } else if (options.allowedIframeHostnames || options.allowedIframeDomains) {\n                  const allowedHostname = (options.allowedIframeHostnames || []).find(function (hostname) {\n                    return hostname === parsed.hostname;\n                  });\n                  const allowedDomain = (options.allowedIframeDomains || []).find(function(domain) {\n                    return parsed.hostname === domain || parsed.hostname.endsWith(`.${domain}`);\n                  });\n                  allowed = allowedHostname || allowedDomain;\n                }\n              } catch (e) {\n                // Unparseable iframe src\n                allowed = false;\n              }\n              if (!allowed) {\n                delete frame.attribs[a];\n                return;\n              }\n            }\n            if (a === 'srcset') {\n              try {\n                parsed = parseSrcset(value);\n                parsed.forEach(function(value) {\n                  if (naughtyHref('srcset', value.url)) {\n                    value.evil = true;\n                  }\n                });\n                parsed = filter(parsed, function(v) {\n                  return !v.evil;\n                });\n                if (!parsed.length) {\n                  delete frame.attribs[a];\n                  return;\n                } else {\n                  value = stringifySrcset(filter(parsed, function(v) {\n                    return !v.evil;\n                  }));\n                  frame.attribs[a] = value;\n                }\n              } catch (e) {\n                // Unparseable srcset\n                delete frame.attribs[a];\n                return;\n              }\n            }\n            if (a === 'class') {\n              const allowedSpecificClasses = allowedClassesMap[name];\n              const allowedWildcardClasses = allowedClassesMap['*'];\n              const allowedSpecificClassesGlob = allowedClassesGlobMap[name];\n              const allowedWildcardClassesGlob = allowedClassesGlobMap['*'];\n              const allowedClassesGlobs = [ allowedSpecificClassesGlob, allowedWildcardClassesGlob ].filter(\n                function(t) {\n                  return t;\n                }\n              );\n              if (allowedSpecificClasses && allowedWildcardClasses) {\n                value = filterClasses(value, deepmerge(allowedSpecificClasses, allowedWildcardClasses), allowedClassesGlobs);\n              } else {\n                value = filterClasses(value, allowedSpecificClasses || allowedWildcardClasses, allowedClassesGlobs);\n              }\n              if (!value.length) {\n                delete frame.attribs[a];\n                return;\n              }\n            }\n            if (a === 'style') {\n              try {\n                const abstractSyntaxTree = postcssParse(name + ' {' + value + '}');\n                const filteredAST = filterCss(abstractSyntaxTree, options.allowedStyles);\n\n                value = stringifyStyleAttributes(filteredAST);\n\n                if (value.length === 0) {\n                  delete frame.attribs[a];\n                  return;\n                }\n              } catch (e) {\n                delete frame.attribs[a];\n                return;\n              }\n            }\n            result += ' ' + a;\n            if (value && value.length) {\n              result += '=\"' + escapeHtml(value, true) + '\"';\n            }\n          } else {\n            delete frame.attribs[a];\n          }\n        });\n      }\n      if (options.selfClosing.indexOf(name) !== -1) {\n        result += ' />';\n      } else {\n        result += '>';\n        if (frame.innerText && !hasText && !options.textFilter) {\n          result += escapeHtml(frame.innerText);\n          addedText = true;\n        }\n      }\n      if (skip) {\n        result = tempResult + escapeHtml(result);\n        tempResult = '';\n      }\n    },\n    ontext: function(text) {\n      if (skipText) {\n        return;\n      }\n      const lastFrame = stack[stack.length - 1];\n      let tag;\n\n      if (lastFrame) {\n        tag = lastFrame.tag;\n        // If inner text was set by transform function then let's use it\n        text = lastFrame.innerText !== undefined ? lastFrame.innerText : text;\n      }\n\n      if (options.disallowedTagsMode === 'discard' && ((tag === 'script') || (tag === 'style'))) {\n        // htmlparser2 gives us these as-is. Escaping them ruins the content. Allowing\n        // script tags is, by definition, game over for XSS protection, so if that's\n        // your concern, don't allow them. The same is essentially true for style tags\n        // which have their own collection of XSS vectors.\n        result += text;\n      } else {\n        const escaped = escapeHtml(text, false);\n        if (options.textFilter && !addedText) {\n          result += options.textFilter(escaped, tag);\n        } else if (!addedText) {\n          result += escaped;\n        }\n      }\n      if (stack.length) {\n        const frame = stack[stack.length - 1];\n        frame.text += text;\n      }\n    },\n    onclosetag: function(name) {\n\n      if (skipText) {\n        skipTextDepth--;\n        if (!skipTextDepth) {\n          skipText = false;\n        } else {\n          return;\n        }\n      }\n\n      const frame = stack.pop();\n      if (!frame) {\n        // Do not crash on bad markup\n        return;\n      }\n      skipText = options.enforceHtmlBoundary ? name === 'html' : false;\n      depth--;\n      const skip = skipMap[depth];\n      if (skip) {\n        delete skipMap[depth];\n        if (options.disallowedTagsMode === 'discard') {\n          frame.updateParentNodeText();\n          return;\n        }\n        tempResult = result;\n        result = '';\n      }\n\n      if (transformMap[depth]) {\n        name = transformMap[depth];\n        delete transformMap[depth];\n      }\n\n      if (options.exclusiveFilter && options.exclusiveFilter(frame)) {\n        result = result.substr(0, frame.tagPosition);\n        return;\n      }\n\n      frame.updateParentNodeMediaChildren();\n      frame.updateParentNodeText();\n\n      if (options.selfClosing.indexOf(name) !== -1) {\n        // Already output />\n        if (skip) {\n          result = tempResult;\n          tempResult = '';\n        }\n        return;\n      }\n\n      result += '</' + name + '>';\n      if (skip) {\n        result = tempResult + escapeHtml(result);\n        tempResult = '';\n      }\n    }\n  }, options.parser);\n  parser.write(html);\n  parser.end();\n\n  return result;\n\n  function initializeState() {\n    result = '';\n    depth = 0;\n    stack = [];\n    skipMap = {};\n    transformMap = {};\n    skipText = false;\n    skipTextDepth = 0;\n  }\n\n  function escapeHtml(s, quote) {\n    if (typeof (s) !== 'string') {\n      s = s + '';\n    }\n    if (options.parser.decodeEntities) {\n      s = s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');\n      if (quote) {\n        s = s.replace(/\"/g, '&quot;');\n      }\n    }\n    // TODO: this is inadequate because it will pass `&0;`. This approach\n    // will not work, each & must be considered with regard to whether it\n    // is followed by a 100% syntactically valid entity or not, and escaped\n    // if it is not. If this bothers you, don't set parser.decodeEntities\n    // to false. (The default is true.)\n    s = s.replace(/&(?![a-zA-Z0-9#]{1,20};)/g, '&amp;') // Match ampersands not part of existing HTML entity\n      .replace(/</g, '&lt;')\n      .replace(/>/g, '&gt;');\n    if (quote) {\n      s = s.replace(/\"/g, '&quot;');\n    }\n    return s;\n  }\n\n  function naughtyHref(name, href) {\n    // Browsers ignore character codes of 32 (space) and below in a surprising\n    // number of situations. Start reading here:\n    // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet#Embedded_tab\n    // eslint-disable-next-line no-control-regex\n    href = href.replace(/[\\x00-\\x20]+/g, '');\n    // Clobber any comments in URLs, which the browser might\n    // interpret inside an XML data island, allowing\n    // a javascript: URL to be snuck through\n    href = href.replace(/<!--.*?-->/g, '');\n    // Case insensitive so we don't get faked out by JAVASCRIPT #1\n    // Allow more characters after the first so we don't get faked\n    // out by certain schemes browsers accept\n    const matches = href.match(/^([a-zA-Z][a-zA-Z0-9.\\-+]*):/);\n    if (!matches) {\n      // Protocol-relative URL starting with any combination of '/' and '\\'\n      if (href.match(/^[/\\\\]{2}/)) {\n        return !options.allowProtocolRelative;\n      }\n\n      // No scheme\n      return false;\n    }\n    const scheme = matches[1].toLowerCase();\n\n    if (has(options.allowedSchemesByTag, name)) {\n      return options.allowedSchemesByTag[name].indexOf(scheme) === -1;\n    }\n\n    return !options.allowedSchemes || options.allowedSchemes.indexOf(scheme) === -1;\n  }\n\n  /**\n   * Filters user input css properties by whitelisted regex attributes.\n   *\n   * @param {object} abstractSyntaxTree  - Object representation of CSS attributes.\n   * @property {array[Declaration]} abstractSyntaxTree.nodes[0] - Each object cointains prop and value key, i.e { prop: 'color', value: 'red' }.\n   * @param {object} allowedStyles       - Keys are properties (i.e color), value is list of permitted regex rules (i.e /green/i).\n   * @return {object}                    - Abstract Syntax Tree with filtered style attributes.\n   */\n  function filterCss(abstractSyntaxTree, allowedStyles) {\n    if (!allowedStyles) {\n      return abstractSyntaxTree;\n    }\n\n    const filteredAST = klona(abstractSyntaxTree);\n    const astRules = abstractSyntaxTree.nodes[0];\n    let selectedRule;\n\n    // Merge global and tag-specific styles into new AST.\n    if (allowedStyles[astRules.selector] && allowedStyles['*']) {\n      selectedRule = deepmerge(\n        allowedStyles[astRules.selector],\n        allowedStyles['*']\n      );\n    } else {\n      selectedRule = allowedStyles[astRules.selector] || allowedStyles['*'];\n    }\n\n    if (selectedRule) {\n      filteredAST.nodes[0].nodes = astRules.nodes.reduce(filterDeclarations(selectedRule), []);\n    }\n\n    return filteredAST;\n  }\n\n  /**\n   * Extracts the style attribues from an AbstractSyntaxTree and formats those\n   * values in the inline style attribute format.\n   *\n   * @param  {AbstractSyntaxTree} filteredAST\n   * @return {string}             - Example: \"color:yellow;text-align:center;font-family:helvetica;\"\n   */\n  function stringifyStyleAttributes(filteredAST) {\n    return filteredAST.nodes[0].nodes\n      .reduce(function(extractedAttributes, attributeObject) {\n        extractedAttributes.push(\n          attributeObject.prop + ':' + attributeObject.value\n        );\n        return extractedAttributes;\n      }, [])\n      .join(';');\n  }\n\n  /**\n    * Filters the existing attributes for the given property. Discards any attributes\n    * which don't match the whitelist.\n    *\n    * @param  {object} selectedRule             - Example: { color: red, font-family: helvetica }\n    * @param  {array} allowedDeclarationsList   - List of declarations which pass whitelisting.\n    * @param  {object} attributeObject          - Object representing the current css property.\n    * @property {string} attributeObject.type   - Typically 'declaration'.\n    * @property {string} attributeObject.prop   - The CSS property, i.e 'color'.\n    * @property {string} attributeObject.value  - The corresponding value to the css property, i.e 'red'.\n    * @return {function}                        - When used in Array.reduce, will return an array of Declaration objects\n    */\n  function filterDeclarations(selectedRule) {\n    return function (allowedDeclarationsList, attributeObject) {\n      // If this property is whitelisted...\n      if (has(selectedRule, attributeObject.prop)) {\n        const matchesRegex = selectedRule[attributeObject.prop].some(function(regularExpression) {\n          return regularExpression.test(attributeObject.value);\n        });\n\n        if (matchesRegex) {\n          allowedDeclarationsList.push(attributeObject);\n        }\n      }\n      return allowedDeclarationsList;\n    };\n  }\n\n  function filterClasses(classes, allowed, allowedGlobs) {\n    if (!allowed) {\n      // The class attribute is allowed without filtering on this tag\n      return classes;\n    }\n    classes = classes.split(/\\s+/);\n    return classes.filter(function(clss) {\n      return allowed.indexOf(clss) !== -1 || allowedGlobs.some(function(glob) {\n        return glob.test(clss);\n      });\n    }).join(' ');\n  }\n}\n\n// Defaults are accessible to you so that you can use them as a starting point\n// programmatically if you wish\n\nconst htmlParserDefaults = {\n  decodeEntities: true\n};\nsanitizeHtml.defaults = {\n  allowedTags: [\n    // Sections derived from MDN element categories and limited to the more\n    // benign categories.\n    // https://developer.mozilla.org/en-US/docs/Web/HTML/Element\n    // Content sectioning\n    'address', 'article', 'aside', 'footer', 'header',\n    'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'hgroup',\n    'main', 'nav', 'section',\n    // Text content\n    'blockquote', 'dd', 'div', 'dl', 'dt', 'figcaption', 'figure',\n    'hr', 'li', 'main', 'ol', 'p', 'pre', 'ul',\n    // Inline text semantics\n    'a', 'abbr', 'b', 'bdi', 'bdo', 'br', 'cite', 'code', 'data', 'dfn',\n    'em', 'i', 'kbd', 'mark', 'q',\n    'rb', 'rp', 'rt', 'rtc', 'ruby',\n    's', 'samp', 'small', 'span', 'strong', 'sub', 'sup', 'time', 'u', 'var', 'wbr',\n    // Table content\n    'caption', 'col', 'colgroup', 'table', 'tbody', 'td', 'tfoot', 'th',\n    'thead', 'tr'\n  ],\n  disallowedTagsMode: 'discard',\n  allowedAttributes: {\n    a: [ 'href', 'name', 'target' ],\n    // We don't currently allow img itself by default, but this\n    // would make sense if we did. You could add srcset here,\n    // and if you do the URL is checked for safety\n    img: [ 'src' ]\n  },\n  // Lots of these won't come up by default because we don't allow them\n  selfClosing: [ 'img', 'br', 'hr', 'area', 'base', 'basefont', 'input', 'link', 'meta' ],\n  // URL schemes we permit\n  allowedSchemes: [ 'http', 'https', 'ftp', 'mailto', 'tel' ],\n  allowedSchemesByTag: {},\n  allowedSchemesAppliedToAttributes: [ 'href', 'src', 'cite' ],\n  allowProtocolRelative: true,\n  enforceHtmlBoundary: false\n};\n\nsanitizeHtml.simpleTransform = function(newTagName, newAttribs, merge) {\n  merge = (merge === undefined) ? true : merge;\n  newAttribs = newAttribs || {};\n\n  return function(tagName, attribs) {\n    let attrib;\n    if (merge) {\n      for (attrib in newAttribs) {\n        attribs[attrib] = newAttribs[attrib];\n      }\n    } else {\n      attribs = newAttribs;\n    }\n\n    return {\n      tagName: newTagName,\n      attribs: attribs\n    };\n  };\n};\n"]},"metadata":{},"sourceType":"script"}