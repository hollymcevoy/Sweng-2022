"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = activities;

var _simpleUpdateIn = _interopRequireDefault(require("simple-update-in"));

var _deleteActivity = require("../actions/deleteActivity");

var _incomingActivity = require("../actions/incomingActivity");

var _markActivity = require("../actions/markActivity");

var _postActivity = require("../actions/postActivity");

var _ActivityClientState = require("../constants/ActivityClientState");

/* eslint no-magic-numbers: ["error", { "ignore": [0, -1] }] */
var DEFAULT_STATE = [];
var DIRECT_LINE_PLACEHOLDER_URL = 'https://docs.botframework.com/static/devportal/client/images/bot-framework-default-placeholder.png';

function getClientActivityID(_ref) {
  var _ref$channelData = _ref.channelData;
  _ref$channelData = _ref$channelData === void 0 ? {} : _ref$channelData;
  var clientActivityID = _ref$channelData.clientActivityID;
  return clientActivityID;
}

function findByClientActivityID(clientActivityID) {
  return function (activity) {
    return getClientActivityID(activity) === clientActivityID;
  };
}

function patchActivity(activity) {
  // Direct Line channel will return a placeholder image for the user-uploaded image.
  // As observed, the URL for the placeholder image is https://docs.botframework.com/static/devportal/client/images/bot-framework-default-placeholder.png.
  // To make our code simpler, we are removing the value if "contentUrl" is pointing to a placeholder image.
  // TODO: [P2] #2869 This "contentURL" removal code should be moved to DirectLineJS adapter.
  // Also, if the "contentURL" starts with "blob:", this means the user is uploading a file (the URL is constructed by URL.createObjectURL)
  // Although the copy/reference of the file is temporary in-memory, to make the UX consistent across page refresh, we do not allow the user to re-download the file either.
  return (0, _simpleUpdateIn["default"])(activity, ['attachments', function () {
    return true;
  }, 'contentUrl'], function (contentUrl) {
    if (contentUrl !== DIRECT_LINE_PLACEHOLDER_URL && !/^blob:/i.test(contentUrl)) {
      return contentUrl;
    }
  });
}

function upsertActivityWithSort(activities, nextActivity) {
  nextActivity = patchActivity(nextActivity);
  var _nextActivity = nextActivity,
      _nextActivity$channel = _nextActivity.channelData;
  _nextActivity$channel = _nextActivity$channel === void 0 ? {} : _nextActivity$channel;
  var nextClientActivityID = _nextActivity$channel.clientActivityID;
  var nextTimestamp = Date.parse(nextActivity.timestamp);
  var nextActivities = activities.filter(function (_ref2) {
    var _ref2$channelData = _ref2.channelData;
    _ref2$channelData = _ref2$channelData === void 0 ? {} : _ref2$channelData;
    var clientActivityID = _ref2$channelData.clientActivityID,
        id = _ref2.id;
    return (// We will remove all "sending messages" activities and activities with same ID
      // "clientActivityID" is unique and used to track if the message has been sent and echoed back from the server
      !(nextClientActivityID && clientActivityID === nextClientActivityID) && !(id && id === nextActivity.id)
    );
  }); // Then, find the right (sorted) place to insert the new activity at, based on timestamp
  // Since clockskew might happen, we will ignore timestamp on messages that are sending

  var indexToInsert = nextActivities.findIndex(function (_ref3) {
    var _ref3$channelData = _ref3.channelData;
    _ref3$channelData = _ref3$channelData === void 0 ? {} : _ref3$channelData;
    var state = _ref3$channelData.state,
        timestamp = _ref3.timestamp;
    return Date.parse(timestamp) > nextTimestamp && state !== _ActivityClientState.SENDING && state !== _ActivityClientState.SEND_FAILED;
  }); // If no right place are found, append it

  nextActivities.splice(~indexToInsert ? indexToInsert : nextActivities.length, 0, nextActivity);
  return nextActivities;
}

function activities() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_STATE;

  var _ref4 = arguments.length > 1 ? arguments[1] : undefined,
      meta = _ref4.meta,
      payload = _ref4.payload,
      type = _ref4.type;

  switch (type) {
    case _deleteActivity.DELETE_ACTIVITY:
      state = (0, _simpleUpdateIn["default"])(state, [function (_ref5) {
        var id = _ref5.id;
        return id === payload.activityID;
      }]);
      break;

    case _markActivity.MARK_ACTIVITY:
      state = (0, _simpleUpdateIn["default"])(state, [function (_ref6) {
        var id = _ref6.id;
        return id === payload.activityID;
      }, 'channelData', payload.name], function () {
        return payload.value;
      });
      break;

    case _postActivity.POST_ACTIVITY_PENDING:
      state = upsertActivityWithSort(state, (0, _simpleUpdateIn["default"])(payload.activity, ['channelData', 'state'], function () {
        return _ActivityClientState.SENDING;
      }));
      break;

    case _postActivity.POST_ACTIVITY_REJECTED:
      state = (0, _simpleUpdateIn["default"])(state, [findByClientActivityID(meta.clientActivityID), 'channelData', 'state'], function () {
        return _ActivityClientState.SEND_FAILED;
      });
      break;

    case _postActivity.POST_ACTIVITY_FULFILLED:
      state = (0, _simpleUpdateIn["default"])(state, [findByClientActivityID(meta.clientActivityID)], function () {
        return (// We will replace the activity with the version from the server
          (0, _simpleUpdateIn["default"])(patchActivity(payload.activity), ['channelData', 'state'], function () {
            return _ActivityClientState.SENT;
          })
        );
      });
      break;

    case _incomingActivity.INCOMING_ACTIVITY:
      // TODO: [P4] #2100 Move "typing" into Constants.ActivityType
      state = upsertActivityWithSort(state, payload.activity);
      break;

    default:
      break;
  }

  return state;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9yZWR1Y2Vycy9hY3Rpdml0aWVzLmpzIl0sIm5hbWVzIjpbIkRFRkFVTFRfU1RBVEUiLCJESVJFQ1RfTElORV9QTEFDRUhPTERFUl9VUkwiLCJnZXRDbGllbnRBY3Rpdml0eUlEIiwiY2hhbm5lbERhdGEiLCJjbGllbnRBY3Rpdml0eUlEIiwiZmluZEJ5Q2xpZW50QWN0aXZpdHlJRCIsImFjdGl2aXR5IiwicGF0Y2hBY3Rpdml0eSIsImNvbnRlbnRVcmwiLCJ0ZXN0IiwidXBzZXJ0QWN0aXZpdHlXaXRoU29ydCIsImFjdGl2aXRpZXMiLCJuZXh0QWN0aXZpdHkiLCJuZXh0Q2xpZW50QWN0aXZpdHlJRCIsIm5leHRUaW1lc3RhbXAiLCJEYXRlIiwicGFyc2UiLCJ0aW1lc3RhbXAiLCJuZXh0QWN0aXZpdGllcyIsImZpbHRlciIsImlkIiwiaW5kZXhUb0luc2VydCIsImZpbmRJbmRleCIsInN0YXRlIiwiU0VORElORyIsIlNFTkRfRkFJTEVEIiwic3BsaWNlIiwibGVuZ3RoIiwibWV0YSIsInBheWxvYWQiLCJ0eXBlIiwiREVMRVRFX0FDVElWSVRZIiwiYWN0aXZpdHlJRCIsIk1BUktfQUNUSVZJVFkiLCJuYW1lIiwidmFsdWUiLCJQT1NUX0FDVElWSVRZX1BFTkRJTkciLCJQT1NUX0FDVElWSVRZX1JFSkVDVEVEIiwiUE9TVF9BQ1RJVklUWV9GVUxGSUxMRUQiLCJTRU5UIiwiSU5DT01JTkdfQUNUSVZJVFkiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUVBOztBQUVBOztBQUNBOztBQUNBOztBQUVBOztBQUVBOztBQVZBO0FBWUEsSUFBTUEsYUFBYSxHQUFHLEVBQXRCO0FBQ0EsSUFBTUMsMkJBQTJCLEdBQy9CLG9HQURGOztBQUdBLFNBQVNDLG1CQUFULE9BQXlFO0FBQUEsOEJBQTFDQyxXQUEwQztBQUFBLG1EQUFOLEVBQU07QUFBQSxNQUEzQkMsZ0JBQTJCLG9CQUEzQkEsZ0JBQTJCO0FBQ3ZFLFNBQU9BLGdCQUFQO0FBQ0Q7O0FBRUQs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b3JlOi8vLyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludCBuby1tYWdpYy1udW1iZXJzOiBbXCJlcnJvclwiLCB7IFwiaWdub3JlXCI6IFswLCAtMV0gfV0gKi9cblxuaW1wb3J0IHVwZGF0ZUluIGZyb20gJ3NpbXBsZS11cGRhdGUtaW4nO1xuXG5pbXBvcnQgeyBERUxFVEVfQUNUSVZJVFkgfSBmcm9tICcuLi9hY3Rpb25zL2RlbGV0ZUFjdGl2aXR5JztcbmltcG9ydCB7IElOQ09NSU5HX0FDVElWSVRZIH0gZnJvbSAnLi4vYWN0aW9ucy9pbmNvbWluZ0FjdGl2aXR5JztcbmltcG9ydCB7IE1BUktfQUNUSVZJVFkgfSBmcm9tICcuLi9hY3Rpb25zL21hcmtBY3Rpdml0eSc7XG5cbmltcG9ydCB7IFBPU1RfQUNUSVZJVFlfRlVMRklMTEVELCBQT1NUX0FDVElWSVRZX1BFTkRJTkcsIFBPU1RfQUNUSVZJVFlfUkVKRUNURUQgfSBmcm9tICcuLi9hY3Rpb25zL3Bvc3RBY3Rpdml0eSc7XG5cbmltcG9ydCB7IFNFTkRfRkFJTEVELCBTRU5ESU5HLCBTRU5UIH0gZnJvbSAnLi4vY29uc3RhbnRzL0FjdGl2aXR5Q2xpZW50U3RhdGUnO1xuXG5jb25zdCBERUZBVUxUX1NUQVRFID0gW107XG5jb25zdCBESVJFQ1RfTElORV9QTEFDRUhPTERFUl9VUkwgPVxuICAnaHR0cHM6Ly9kb2NzLmJvdGZyYW1ld29yay5jb20vc3RhdGljL2RldnBvcnRhbC9jbGllbnQvaW1hZ2VzL2JvdC1mcmFtZXdvcmstZGVmYXVsdC1wbGFjZWhvbGRlci5wbmcnO1xuXG5mdW5jdGlvbiBnZXRDbGllbnRBY3Rpdml0eUlEKHsgY2hhbm5lbERhdGE6IHsgY2xpZW50QWN0aXZpdHlJRCB9ID0ge30gfSkge1xuICByZXR1cm4gY2xpZW50QWN0aXZpdHlJRDtcbn1cblxuZnVuY3Rpb24gZmluZEJ5Q2xpZW50QWN0aXZpdHlJRChjbGllbnRBY3Rpdml0eUlEKSB7XG4gIHJldHVybiBhY3Rpdml0eSA9PiBnZXRDbGllbnRBY3Rpdml0eUlEKGFjdGl2aXR5KSA9PT0gY2xpZW50QWN0aXZpdHlJRDtcbn1cblxuZnVuY3Rpb24gcGF0Y2hBY3Rpdml0eShhY3Rpdml0eSkge1xuICAvLyBEaXJlY3QgTGluZSBjaGFubmVsIHdpbGwgcmV0dXJuIGEgcGxhY2Vob2xkZXIgaW1hZ2UgZm9yIHRoZSB1c2VyLXVwbG9hZGVkIGltYWdlLlxuICAvLyBBcyBvYnNlcnZlZCwgdGhlIFVSTCBmb3IgdGhlIHBsYWNlaG9sZGVyIGltYWdlIGlzIGh0dHBzOi8vZG9jcy5ib3RmcmFtZXdvcmsuY29tL3N0YXRpYy9kZXZwb3J0YWwvY2xpZW50L2ltYWdlcy9ib3QtZnJhbWV3b3JrLWRlZmF1bHQtcGxhY2Vob2xkZXIucG5nLlxuICAvLyBUbyBtYWtlIG91ciBjb2RlIHNpbXBsZXIsIHdlIGFyZSByZW1vdmluZyB0aGUgdmFsdWUgaWYgXCJjb250ZW50VXJsXCIgaXMgcG9pbnRpbmcgdG8gYSBwbGFjZWhvbGRlciBpbWFnZS5cblxuICAvLyBUT0RPOiBbUDJdICMyODY5IFRoaXMgXCJjb250ZW50VVJMXCIgcmVtb3ZhbCBjb2RlIHNob3VsZCBiZSBtb3ZlZCB0byBEaXJlY3RMaW5lSlMgYWRhcHRlci5cblxuICAvLyBBbHNvLCBpZiB0aGUgXCJjb250ZW50VVJMXCIgc3RhcnRzIHdpdGggXCJibG9iOlwiLCB0aGlzIG1lYW5zIHRoZSB1c2VyIGlzIHVwbG9hZGluZyBhIGZpbGUgKHRoZSBVUkwgaXMgY29uc3RydWN0ZWQgYnkgVVJMLmNyZWF0ZU9iamVjdFVSTClcbiAgLy8gQWx0aG91Z2ggdGhlIGNvcHkvcmVmZXJlbmNlIG9mIHRoZSBmaWxlIGlzIHRlbXBvcmFyeSBpbi1tZW1vcnksIHRvIG1ha2UgdGhlIFVYIGNvbnNpc3RlbnQgYWNyb3NzIHBhZ2UgcmVmcmVzaCwgd2UgZG8gbm90IGFsbG93IHRoZSB1c2VyIHRvIHJlLWRvd25sb2FkIHRoZSBmaWxlIGVpdGhlci5cblxuICByZXR1cm4gdXBkYXRlSW4oYWN0aXZpdHksIFsnYXR0YWNobWVudHMnLCAoKSA9PiB0cnVlLCAnY29udGVudFVybCddLCBjb250ZW50VXJsID0+IHtcbiAgICBpZiAoY29udGVudFVybCAhPT0gRElSRUNUX0xJTkVfUExBQ0VIT0xERVJfVVJMICYmICEvXmJsb2I6L2l1LnRlc3QoY29udGVudFVybCkpIHtcbiAgICAgIHJldHVybiBjb250ZW50VXJsO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHVwc2VydEFjdGl2aXR5V2l0aFNvcnQoYWN0aXZpdGllcywgbmV4dEFjdGl2aXR5KSB7XG4gIG5leHRBY3Rpdml0eSA9IHBhdGNoQWN0aXZpdHkobmV4dEFjdGl2aXR5KTtcblxuICBjb25zdCB7IGNoYW5uZWxEYXRhOiB7IGNsaWVudEFjdGl2aXR5SUQ6IG5leHRDbGllbnRBY3Rpdml0eUlEIH0gPSB7fSB9ID0gbmV4dEFjdGl2aXR5O1xuXG4gIGNvbnN0IG5leHRUaW1lc3RhbXAgPSBEYXRlLnBhcnNlKG5leHRBY3Rpdml0eS50aW1lc3RhbXApO1xuICBjb25zdCBuZXh0QWN0aXZpdGllcyA9IGFjdGl2aXRpZXMuZmlsdGVyKFxuICAgICh7IGNoYW5uZWxEYXRhOiB7IGNsaWVudEFjdGl2aXR5SUQgfSA9IHt9LCBpZCB9KSA9PlxuICAgICAgLy8gV2Ugd2lsbCByZW1vdmUgYWxsIFwic2VuZGluZyBtZXNzYWdlc1wiIGFjdGl2aXRpZXMgYW5kIGFjdGl2aXRpZXMgd2l0aCBzYW1lIElEXG4gICAgICAvLyBcImNsaWVudEFjdGl2aXR5SURcIiBpcyB1bmlxdWUgYW5kIHVzZWQgdG8gdHJhY2sgaWYgdGhlIG1lc3NhZ2UgaGFzIGJlZW4gc2VudCBhbmQgZWNob2VkIGJhY2sgZnJvbSB0aGUgc2VydmVyXG4gICAgICAhKG5leHRDbGllbnRBY3Rpdml0eUlEICYmIGNsaWVudEFjdGl2aXR5SUQgPT09IG5leHRDbGllbnRBY3Rpdml0eUlEKSAmJiAhKGlkICYmIGlkID09PSBuZXh0QWN0aXZpdHkuaWQpXG4gICk7XG5cbiAgLy8gVGhlbiwgZmluZCB0aGUgcmlnaHQgKHNvcnRlZCkgcGxhY2UgdG8gaW5zZXJ0IHRoZSBuZXcgYWN0aXZpdHkgYXQsIGJhc2VkIG9uIHRpbWVzdGFtcFxuICAvLyBTaW5jZSBjbG9ja3NrZXcgbWlnaHQgaGFwcGVuLCB3ZSB3aWxsIGlnbm9yZSB0aW1lc3RhbXAgb24gbWVzc2FnZXMgdGhhdCBhcmUgc2VuZGluZ1xuXG4gIGNvbnN0IGluZGV4VG9JbnNlcnQgPSBuZXh0QWN0aXZpdGllcy5maW5kSW5kZXgoXG4gICAgKHsgY2hhbm5lbERhdGE6IHsgc3RhdGUgfSA9IHt9LCB0aW1lc3RhbXAgfSkgPT5cbiAgICAgIERhdGUucGFyc2UodGltZXN0YW1wKSA+IG5leHRUaW1lc3RhbXAgJiYgc3RhdGUgIT09IFNFTkRJTkcgJiYgc3RhdGUgIT09IFNFTkRfRkFJTEVEXG4gICk7XG5cbiAgLy8gSWYgbm8gcmlnaHQgcGxhY2UgYXJlIGZvdW5kLCBhcHBlbmQgaXRcbiAgbmV4dEFjdGl2aXRpZXMuc3BsaWNlKH5pbmRleFRvSW5zZXJ0ID8gaW5kZXhUb0luc2VydCA6IG5leHRBY3Rpdml0aWVzLmxlbmd0aCwgMCwgbmV4dEFjdGl2aXR5KTtcblxuICByZXR1cm4gbmV4dEFjdGl2aXRpZXM7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGFjdGl2aXRpZXMoc3RhdGUgPSBERUZBVUxUX1NUQVRFLCB7IG1ldGEsIHBheWxvYWQsIHR5cGUgfSkge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIERFTEVURV9BQ1RJVklUWTpcbiAgICAgIHN0YXRlID0gdXBkYXRlSW4oc3RhdGUsIFsoeyBpZCB9KSA9PiBpZCA9PT0gcGF5bG9hZC5hY3Rpdml0eUlEXSk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgTUFSS19BQ1RJVklUWTpcbiAgICAgIHN0YXRlID0gdXBkYXRlSW4oXG4gICAgICAgIHN0YXRlLFxuICAgICAgICBbKHsgaWQgfSkgPT4gaWQgPT09IHBheWxvYWQuYWN0aXZpdHlJRCwgJ2NoYW5uZWxEYXRhJywgcGF5bG9hZC5uYW1lXSxcbiAgICAgICAgKCkgPT4gcGF5bG9hZC52YWx1ZVxuICAgICAgKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBQT1NUX0FDVElWSVRZX1BFTkRJTkc6XG4gICAgICBzdGF0ZSA9IHVwc2VydEFjdGl2aXR5V2l0aFNvcnQoXG4gICAgICAgIHN0YXRlLFxuICAgICAgICB1cGRhdGVJbihwYXlsb2FkLmFjdGl2aXR5LCBbJ2NoYW5uZWxEYXRhJywgJ3N0YXRlJ10sICgpID0+IFNFTkRJTkcpXG4gICAgICApO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFBPU1RfQUNUSVZJVFlfUkVKRUNURUQ6XG4gICAgICBzdGF0ZSA9IHVwZGF0ZUluKFxuICAgICAgICBzdGF0ZSxcbiAgICAgICAgW2ZpbmRCeUNsaWVudEFjdGl2aXR5SUQobWV0YS5jbGllbnRBY3Rpdml0eUlEKSwgJ2NoYW5uZWxEYXRhJywgJ3N0YXRlJ10sXG4gICAgICAgICgpID0+IFNFTkRfRkFJTEVEXG4gICAgICApO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFBPU1RfQUNUSVZJVFlfRlVMRklMTEVEOlxuICAgICAgc3RhdGUgPSB1cGRhdGVJbihzdGF0ZSwgW2ZpbmRCeUNsaWVudEFjdGl2aXR5SUQobWV0YS5jbGllbnRBY3Rpdml0eUlEKV0sICgpID0+XG4gICAgICAgIC8vIFdlIHdpbGwgcmVwbGFjZSB0aGUgYWN0aXZpdHkgd2l0aCB0aGUgdmVyc2lvbiBmcm9tIHRoZSBzZXJ2ZXJcbiAgICAgICAgdXBkYXRlSW4ocGF0Y2hBY3Rpdml0eShwYXlsb2FkLmFjdGl2aXR5KSwgWydjaGFubmVsRGF0YScsICdzdGF0ZSddLCAoKSA9PiBTRU5UKVxuICAgICAgKTtcblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIElOQ09NSU5HX0FDVElWSVRZOlxuICAgICAgLy8gVE9ETzogW1A0XSAjMjEwMCBNb3ZlIFwidHlwaW5nXCIgaW50byBDb25zdGFudHMuQWN0aXZpdHlUeXBlXG4gICAgICBzdGF0ZSA9IHVwc2VydEFjdGl2aXR5V2l0aFNvcnQoc3RhdGUsIHBheWxvYWQuYWN0aXZpdHkpO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gc3RhdGU7XG59XG4iXX0=